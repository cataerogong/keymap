<!-- <!DOCTYPE html> -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<style>
:root {
    --cols: 2; /* mapping-list columns */
    --c0: black; /* highlight color */
    --c1: lightblue; /* highlight bg color */
    --c2: lightseagreen; /* border color */
    --c3: black; /* unset fore color */
    --c4: whitesmoke; /* unset bg color */
    --bdc: gray;
    --ks: calc(1rem * var(--ks1, 0.75)); /* key font size */
    --kw: calc(1rem * var(--kw1, 3)); /* key width */
    --kh: calc(1rem * var(--kh1, 3)); /* key height */
    --kt: calc(1rem * var(--kt2, 0.75)); /* keycap description text size */
    --ui-fc: black;
    --ui-bgc: lightblue;
    --ui-bdc: lightseagreen;
}
[data-kbhint="true"] {
    --ks: calc(1rem * var(--ks2, 0.9)); /* key font size */
    --kw: calc(1rem * var(--kw2, 5)); /* key width */
    --kh: calc(1rem * var(--kh2, 5)); /* key height */
}

body {
    font-family: Consolas, sans-serif;
    font-size: 0.9rem;
    margin: 0px;
    padding: 0px 10px;
    height: 100%;
    background-color: whitesmoke;
    overflow-y: hidden;
    display: flex;
    flex-flow: column;
    width: var(--w);
}

textarea {
    resize: none;
    font-size: 0.9rem;
    font-family: Consolas, sans-serif;
    border: 0px solid gray;
    outline: 0px;
    background-color: whitesmoke;
    padding: 5px;
}

textarea:focus {
    background-color: cornsilk;
}

input[type="checkbox"] {
    vertical-align: bottom;
}

keyboard {
    position: relative;
    box-sizing: border-box;
    border: 2px solid var(--bdc);
    border-radius: 10px;
    /* background-color: var(--bdc); */
    /* background-image: linear-gradient(0deg, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.85) 100%); */
    padding: 10px;
    height: fit-content;
    margin: 5px;
}
keyboard:hover {
    box-shadow: 0px 0px 5px var(--c2);
    border-color: var(--c2);
    /* background-color: var(--c1); */
}

#kb_std {
    display: flex;
    flex-flow: row;
    gap: 10px;
    width: fit-content;
}

#kb_ext {
    display: flex;
    flex-flow: column;
    gap: 3px;
    width: var(--kbw);
}

kb_pc,
kb_main,
kb_dir,
kb_num,
kb_mac {
    display: grid;
    gap: 3px;
    width: max-content;
    height: fit-content;
    /* overflow: hidden; */
}
kb_pc,
kb_mac {
    grid-template-columns: repeat(3, max-content);
    grid-auto-flow: row;
    gap: 10px;
}

kb_pc kb_main {
    grid-template-rows: var(--kh) 10px repeat(5, var(--kh));
    grid-auto-rows: var(--kh);
}

kb_pc kb_dir {
    /* grid-template: var(--kh) 10px repeat(5, var(--kh)) / repeat(3, var(--kw)); */
    grid-template-rows: var(--kh) 10px repeat(5, var(--kh));
    grid-auto-rows: var(--kh);
}

kb_pc kb_num {
    grid-template: repeat(5, var(--kh)) / repeat(4, var(--kw));
    margin-top: calc(var(--kh) + 10px + 3px * 2);
}

kb_mac kb_main {
    grid-template-rows: repeat(6, var(--kh));
    grid-auto-rows: var(--kh);
}

kb_mac kb_dir {
    grid-template-rows: repeat(6, var(--kh));
    grid-auto-rows: var(--kh);
}

kb_mac kb_num {
    grid-template: repeat(6, var(--kh)) / repeat(4, var(--kw));
}

kr {
    display: flex;
    justify-content: space-between;
    height: var(--kh);
    gap: 3px;
}

[data-layout="mac"] kr {
    gap: 5px;
}

kr.Fn {
    display: grid;
    grid-auto-flow: column;
    grid-template-columns: min-content 1fr repeat(4, min-content) 1fr repeat(4, min-content) 1fr repeat(4, min-content);
}

krx {
    display: flex;
    justify-content: start;
    flex-wrap: wrap;
    min-height: var(--kh);
    height: auto;
    gap: 3px;
}

[data-kbsize="0"] #kb_std {
    border-width: 0px;
    padding-top: 0px;
    padding-bottom: 0px;
    height: 0px;
    overflow: hidden;
}

[data-kbext="false"] #kb_ext,
[data-kbsize="0"] :is(kb_dir, kb_num),
[data-kbsize="1"] :is(kb_dir, kb_num),
[data-kbsize="2"] kb_num {
    display: none;
}

k, .k {
    color: var(--c3);
    font-size: var(--ks);
    font-weight: bold;
    box-sizing: border-box;
    border: 1px solid darkgray;
    border-radius: 5px;
    background-color: var(--c4);
    width: var(--kw);
    height: var(--kh);
    padding: 3px 3px;
    display: flex;
    flex-flow: column;
}
k {
    cursor: pointer;
}
k.set {
    color: var(--c0);
    border-color: var(--c2);
    background-color: var(--c1);
}
k.set.group {
    background-color: var(--gc, var(--c1));
}
k.sel {
    outline: 2px dashed lightseagreen;
}
k.rel {
    border-width: 2px;
}
k.no-rel {
    filter: opacity(0.5);
}
.kinfo.no-rel {
    display: none;
}
.kinfo.combo.group {
    align-self: start;
    padding: 3px;
    border: 1px solid darkgray;
    border-radius: 5px;
    background-color: var(--gc, transparent);
}

.k1 {
    width: var(--kw);
}

.k13 {
    width: calc(var(--kw) * 1.3 + 3px);
}

.k15 {
    width: calc(var(--kw) * 1.5 + 3px);
}

.k2,
.k2h {
    width: calc(var(--kw) * 2 + 3px);
}

.k25 {
    width: calc(var(--kw) * 2.5 + 4px);
}

.kspace {
    flex: 1;
}

.k2v {
    grid-row: span 2;
    height: calc(var(--kh) * 2 + 3px)
}

.k05 {
    width: calc(var(--kw) / 2);
}

.k05v {
    height: calc(var(--kh) / 2);
}

.k2h {
    grid-column: span 2;
}

d {
    display: inline-block;
    border: 1px solid transparent;
    height: var(--kh);
}

.d1 {
    box-sizing: border-box;
    height: var(--kh);
    min-width: var(--kw);
}

.d3 {
    width: calc(var(--kw) * 3 + 3px * 2);
    grid-column: span 3;
}

.dis {
    cursor: not-allowed;
    background-color: pink;
    background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%);
    background-size: calc(var(--kw) / 2) calc(var(--kh) / 2);
}

.na {
    border-width: 0px !important;
    color: gray !important;
}

kn, km {
    box-sizing: border-box;
    display: inline-block;
    line-height: 1rem;
    vertical-align: middle;
}
kn {
    font-weight: bold;
    color: var(--c0);
    background-color: var(--c1);
    border: 1px solid var(--c2);
    border-radius: 5px;
    height: fit-content;
    width: fit-content;
    min-width: 2rem;
    padding: 2px 5px;
    margin: 0px 1px;
    text-align: center;
}
kn.ck {
    font-weight: normal;
}
kn.sel {
    outline: 2px dotted lightseagreen;
    outline-offset: 1px;
}

.f-end {
    justify-self: end;
    text-align: right;
}

km {
    width: fit-content;
    height: fit-content;
    white-space: pre-wrap;
    word-break: break-all;
    word-wrap: break-word;
    padding: 2px 5px;
    margin-right: 5px;
    border: 1px solid lightgray;
    border-radius: 5px;
    background-color: lightgray;
}

.mod_color {
    color: white;
    --m-c1: var(--mod-c1, white);
    --m-c2: var(--mod-c2, white);;
    --m-c3: var(--mod-c1, var(--mod-c2, white));
    --m-c4: var(--mod-c2, var(--mod-c1, white));
    background-image: linear-gradient(135deg, var(--m-c1) 0%, var(--m-c1) 20%, var(--m-c3) 20%, var(--m-c3) 50%, var(--m-c4) 50%, var(--m-c4) 80%, var(--m-c2) 80%, var(--m-c2) 100%);
}

.ktn, .ktr, .ktm {
    box-sizing: border-box;
    pointer-events: none;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
}
.ktn {
    text-align: right;
}
.ktr {
    overflow-wrap: anywhere;
    flex: 1;
    font-size: var(--kt);
    white-space: pre-wrap;
    display: grid;
    grid-template: max-content / 1fr max-content;
    text-align: right;
}
.ktr .modkeys {
    /* flex: 1; */
    grid-row: span 2;

}
.ktr .mk {
    font-size: var(--ks);
    height: calc(var(--ks) + 4px);
    min-width: calc(var(--ks) + 4px);
    text-align: center;
    display: inline-block;
    box-sizing: border-box;
    border-radius: 3px;
    margin-left: 2px;
    padding: 0px 2px;
    justify-self: end;
}
k.mod .ktn,
k.mod .ktr .mk {
    text-decoration: underline dashed;
    text-underline-offset: 2px;
}
k.mod .ktr .mk {
    outline: 1px solid darkgray;
}
k.set .ktr .mk {
    /* outline: 1px solid darkgray; */
    background-color: var(--c1);
}
k.set.group .ktr .mk {
    outline: 1px solid darkgray;
}
.ktr .mod {
    font-size: 11px;
    display: inline-block;
    box-sizing: border-box;
    outline: 1px solid darkgray;
    border-radius: 2px;
    margin: 1px 1px 0px 0px;
    padding: 0px 2px;
    text-align: center;
}
.ktr .mod_raw {
    height: 12px;
    background-color: var(--c1);
    margin-top: 3px;
}
.ktr .mod_chr {
    height: 12px;
    line-height: 12px;
    min-width: 12px;
    background-color: var(--c1);
    margin-top: 3px;
}
.ktr .mod_dot {
    height: 8px;
    min-width: 8px;
    background-color: var(--c1);
    margin-top: 5px;
}
.ktr .mod_dot.mod_color {
    --m-c3: var(--mod-c1, white);
    --m-c4: var(--mod-c2, white);
}
kn.na,
.ktr .na {
    background-color: whitesmoke !important;
    background-image: unset !important;
    outline: 1px solid gray !important;
}
k.set .ktr .cnt {
    justify-self: right;
    color: gray;
    margin-top: 5px;
    font-size: 11px;
    height: 13px;
    min-width: 13px;
    border-radius: 4px;
    /* background-color: rgba(255, 255, 255, 0.5); */
    text-align: center;
}

.ktm {
    overflow: hidden;
    font-size: var(--kt);
    font-weight: normal;
    white-space: pre-wrap;
}

[data-kbhint="true"] .ktn {
    display: none;
}
[data-kbhint="false"] .ktr,
[data-kbhint="false"] .ktm {
    display: none;
}
[data-kbhint="true"] #btn_hint {
    background-color: var(--ui-bdc);
}
[data-kbext="true"] #btn_kbext {
    background-color: var(--ui-bdc);
}

[data-showall="true"] #btn_showall {
    background-color: var(--ui-bdc);
}

.kms_info {
    box-sizing: border-box;
    border: 1px solid var(--c2);
    border-radius: 5px;
    background-color: whitesmoke;
    width: fit-content;
    height: fit-content;
    padding: 5px;
    display: grid;
    grid-template-columns: max-content 1fr;
    gap: 3px 1px;
    align-content: flex-start;
    pointer-events: none;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: calc(var(--w) * 0.5);
    position: absolute;
    box-shadow: 0px 3px 5px #000;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 2;
}

.btn {
    padding: 3px 6px;
    border: 1px solid var(--ui-bdc);
    cursor: pointer;
}

.btn.danger:hover,
.smbtn.danger:hover {
    color: black;
    border-color: red;
    background-color:lightpink;
}

.smbtn {
    box-sizing: border-box;
    font-size: 12px;
    line-height: 12px;
    text-align: center;
    padding: 0px 3px;
    height: 20px;
    min-width: 24px;
    border: 1px solid var(--ui-bdc);
}
.smbtn {
    cursor: pointer;
}

.tabbtn {
    display: inline-block;
    border: 1px solid gray;
    border-bottom: 0px;
    border-radius: 5px 5px 0 0;
    padding: 5px 10px 0px;
    cursor: pointer;
}

.btn:hover,
.smbtn:hover,
.tabbtn:hover,
.tabbtn.sel,
[data-view="k"] #tabbtn_kb,
[data-view="l"] #tabbtn_list,
[data-view="j"] #tabbtn_json {
    border-color: var(--ui-bdc);
    background-color: var(--ui-bgc);
    color: var(--ui-fc);
}

.btn_l {
    font-size: 0.8rem;
    line-height: 1rem;
    height: 1.3rem;
    vertical-align: bottom;
    border: 1px solid lightgray;
    color: darkgray;
    cursor: pointer;
}

.btn_l:hover,
.btn_l_cur {
    font-weight: bold;
    color: var(--c0);
    border-color: var(--c2);
    background-color: var(--c1);
}

#kb_ops,
#json_ops {
    display: flex;
    border: 1px solid gray;
    align-items: center;
    height: 2rem;
}

[data-view="k"] #json_ops,
[data-view="l"] #json_ops,
[data-view="j"] #kb_ops {
    display: none;
}

.tab {
    display: flex;
    flex-flow: column;
    box-sizing: border-box;
    height: 0px;
    width: 100%;
    overflow-y: hidden;
    border-style: solid;
    border-color: gray;
    border-width: 0px 1px;
    background-color: whitesmoke;
}

#tab_kb {
    width: fit-content;
    overflow-y: auto;
}
[data-view="k"] #tab_kb ,
[data-view="l"] #tab_list,
[data-view="j"] #tab_json {
    height: 100%;
    border-bottom-width: 1px;
}

#list {
    display: grid;
    grid-template-columns: repeat(var(--cols), max-content 1fr);
    gap: 10px 2px;
    align-content: flex-start;
    padding: 10px;
    box-sizing: border-box;
    height: 100%;
    width: 100%;
    overflow-y: auto;
}

#json {
    border: 0px;
    width: 100%;
    height: 100%;
}

dialog {
    display: flex;
    flex-flow: column;
    align-content: flex-start;
    gap: 1rem;
    border: 2px solid var(--ui-bdc);
    border-radius: 10px;
    box-shadow: 0px 5px 5px;
    margin-left: calc(var(--w) / 2);
    transform: translateX(-50%);
}

.kmdlg {
    width: 40rem;
    height: 20rem;
}

.name_dlg input[type="text"] {
    font-size: 1rem;
    height: 1.6em;
}

.stdlg .sts {
    display: grid;
    grid-auto-flow: row;
    grid-template-columns: repeat(8, max-content);
    gap: 5px 1rem;
    align-items:start;
    padding-bottom: 10px;
    border-bottom: 1px solid gray;
}
.stdlg .subttl {
    grid-column: 1 / -1;
    margin-top: 1rem;
    font-weight: bold;
    background-color: var(--ui-bgc);
    padding: 3px;
    text-align: center;
}
.stdlg span {
    text-align: end;
}
.stdlg input[type="text"] {
    font-size: 0.9rem;
    height: 1.4em;
}

.about {
    height: fit-content;
    color: gray;
    padding-bottom: 2px;
    text-align: right;
}

.prof_name {
    color: var(--ui-fc);
    border: 1px solid var(--ui-bdc);
    border-radius: 5px;
    padding: 3px 1em;
    width: 20em;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.prof_name:hover {
    font-weight: bold;
    background-color: var(--ui-bgc);
}
.prof_list {
    box-sizing: content-box;
    outline: 1px solid var(--ui-bdc);
    border-radius: 5px;
    background-color: whitesmoke;
    width: 22em;
    max-height: 90%;
    padding: 5px;
    overflow-y: auto;
    overflow-x: hidden;
    transition: opacity 0.3s;
    z-index: 2;
}
.prof_list .prof_name {
    margin-bottom: 5px;
}
.prof_cur {
    font-weight: bold;
    background-color: var(--ui-bgc);
}
.prof_cmd {
    background-color: cornsilk;
    border-color: goldenrod;
    font-weight: bold;
}
.rnd {
    border-radius: 5px;
}
#row_cap {
    display: flex;
    box-sizing: border-box;
    font-family: sans-serif;
    font-size: 1.1rem;
    font-weight: bold;
    height: 2rem;
    line-height: 2rem;
    color: gray;
    background-color: lightgray;
}
.slogan {
    font-size: 75%;
}
#row_tabbar {
    display: flex;
    gap: 3px;
    margin-top: 5px;
}
#comment {
    flex: 1;
    min-height: 2rem;
}
#row_name {
    position: absolute;
    display: flex;
    gap: 2px;
    padding: 3px 0px;
    width: var(--kbw);
    pointer-events: none;
}
#pname_keymap {
    color: var(--ui-fc);
    border: 1px solid var(--ui-bdc);
    border-radius: 5px;
    padding: 3px 1em;
    font-weight: bold;
    background-color: var(--ui-bgc);
}
#pname_layer {
    padding: 3px 6px;
    border: 1px solid var(--ui-bdc);
    border-radius: 5px;
    background-color: whitesmoke;
}
[data-ui="single"] body {
    height: fit-content;
    overflow: auto;
}
[data-ui="tab"] #row_name,
[data-ui="single"] :is(#btn_load_file, #btn_save_file, #row_tabbar, #kb_ops, #comment, #json_ops, #tab_json) {
    display: none;
}
[data-ui="single"] :is(#tab_kb, #tab_list) {
    height: fit-content;
    border-width: 1px;
}
[data-ui="single"] #tab_kb {
    border-color: transparent;
}
#btn_ui_single,
[data-ui="single"] #btn_ui_tab {
    text-shadow: #000 1px 0 0, #000 0 1px 0, #000 -1px 0 0, #000 0 -1px 0;
    color: lightseagreen;
    color: var(--ui-bdc);
    cursor: pointer;
    font-size: 125%;
}
[data-ui="single"] #btn_ui_single {
    text-shadow: unset;
    color: unset;
    font-size: unset;
    cursor: unset;
}
[data-layout="mac"] kb_pc {
    display: none;
}
[data-layout="pc"] kb_mac {
    display: none;
}
[data-layout="mac"] #btn_layout {
    background-color: var(--ui-bdc);
}
.btn_icon {
    cursor: pointer;
    border: 1px solid var(--ui-bdc);
    border-radius: 5px;
    background-color: whitesmoke;
    filter: grayscale(0.8);
}
.btn_icon:hover {
    filter: grayscale(0);
}

/* exe mode */
/* [data-launch-mode="exe"] :is(#btn_load_file, #btn_save_file, #btn_save_as_img) {
    display: none;
} */
</style>
</head>

<body>
<div id="row_cap">
    <span id="btn_load_file" class="btn_icon BIND-CLICK" title="‰ªéÊñá‰ª∂ËΩΩÂÖ•" style="margin-left: 10px;align-self: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 72 72"><path fill="lightseagreen" d="M15.464 59.626c.14-.169 2.356-7.826 2.9-9.627c.457-1.513 3.962-15.27 6.16-25.07c.008-.132 32.484-.614 32.484-.614v-7.367l-27.493-.571c-.08-1.236-1.004-4.122-2.137-4.122l-12.587-.198c-1.103 0-2.832 1.34-2.832 2.444c0 0-.25 36.183-.25 44.977c0 1.328 3.734.174 3.755.148"/><path fill="lightblue" d="M23.944 24.315c0 .078-.008.156-.025.232c-.275 1.226-6.735 30.042-7.363 32.124a9.835 9.835 0 0 1-1.765 3.291l43.112.01c1.138 0 1.521 0 2.152-2.39c.667-2.53 6.698-30.269 7.342-33.232l.006-.035z"/></svg>
    </span>
    <span id="btn_save_file" class="btn_icon BIND-CLICK" title="‰øùÂ≠òËá≥Êñá‰ª∂" style="margin: 0px 3px;align-self: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g transform="rotate(180 12 12)"><path fill="lightseagreen" d="M5 21h14a2 2 0 0 0 2-2V8l-5-5H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2M7 5h4v2h2V5h2v4H7zm0 8h10v6H7z"/></g></svg>
    </span>
    <span style="flex: 1;">&nbsp;</span>
    <span>ÈîÆË∞±</span>
    <span class="slogan">
        ‚Äî‚Äî ËÆ©‚ÄúËÆ∞ÂΩï„ÄÅÂ±ïÁ§∫Âø´Êç∑ÈîÆ‚ÄùÂèòÂæó
        <span id="btn_ui_tab" class="BIND-CLICK" title="ÂàÜÈ°µÊ®°Âºè">ÁÆÄ</span>
        <span id="btn_ui_single" class="BIND-CLICK" title="ÂçïÈ°µÊ®°Âºè">Âçï</span>
        <span>&nbsp;</span>
    </span>
    <span id="btn_save_as_img" class="btn_icon BIND-CLICK" title="ÁîüÊàêÂçïÈ°µÊ®°ÂºèÂõæÁâá" style="margin: 0px 10px;align-self: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="lightseagreen" d="m11.18 8.933l3.232-5.596q2.025.523 3.662 2.046q1.638 1.523 2.38 3.55zM8.888 11.26L5.673 5.606Q6.946 4.358 8.57 3.679Q10.194 3 12 3q.383 0 .875.047t.746.097zm-5.6 2.97q-.15-.638-.219-1.176Q3 12.515 3 12q0-1.583.537-3.042q.536-1.46 1.567-2.74l4.588 8.013zm6.403 6.472q-2.14-.562-3.819-2.104q-1.679-1.542-2.344-3.588h9.402zM12 21q-.375 0-.81-.05q-.436-.05-.71-.1l4.71-7.994l3.156 5.519q-1.254 1.248-2.897 1.937Q13.806 21 12 21m6.896-3.217L14.308 9.73h6.405q.131.58.21 1.157Q21 11.465 21 12q0 1.615-.536 3.062q-.535 1.446-1.568 2.72"/></svg>
    </span>
</div>
<div id="row_name">
    <span style="font-weight: bold;padding: 3px 10px;font-size:1rem;">ÈîÆË∞±</span>
    <span id="pname_keymap"></span>
    <span style="font-weight: bold;padding: 3px 0px;">- Â±Ç</span>
    <span id="pname_layer"></span>
</div>
<div id="row_tabbar">
    <div style="flex: 1;display: flex;padding: 2px 0px;gap:2px;">
        <span style="font-weight: bold;padding: 3px 10px;font-size:1rem;">ÈîÆË∞±</span>
        <div id="prof_name" class="prof_name prof_cur" style="margin-right: 5px;"></div>
        <button id="btn_clr" class="btn rnd danger BIND-CLICK">Ê∏ÖÁ©∫</button>
        <button id="btn_del" class="btn rnd danger BIND-CLICK">Âà†Èô§</button>
        <button id="btn_saveas" class="btn rnd BIND-CLICK">Âè¶Â≠ò‰∏∫</button>
        <span style="flex: 1;">&nbsp;</span>
    </div>
    <span id="tabbtn_kb" class="tabbtn BIND-CLICK">ÈîÆÂõæ</span>
    <span id="tabbtn_list" class="tabbtn BIND-CLICK">ÈîÆË°®</span>
    <span id="tabbtn_json" class="tabbtn BIND-CLICK">Êï∞ÊçÆ</span>
</div>
<div id="kb_ops">
    <span>&nbsp;</span>
    <button id="btn_setting" class="smbtn kb_op BIND-CLICK" title="UI ËÆæÁΩÆ">üõ†</button>
    <!-- <button id="btn_shorten" class="smbtn kb_op BIND-CLICK" title="Êî∂Áº©‰∏ªÈîÆÁõò">‚ûñ</button>
    <button id="btn_expand" class="smbtn kb_op BIND-CLICK" title="Êâ©Â±ï‰∏ªÈîÆÁõò">‚ûï</button>
    <button id="btn_kbext" class="smbtn kb_op BIND-CLICK" title="Êâ©Â±ïÈîÆÂå∫">‚Üï</button> -->
    <button id="btn_hint" class="smbtn kb_op BIND-CLICK" title="ÈîÆÂ∏ΩÊèêÁ§∫">üî£</button>
    <button id="btn_layout" class="smbtn kb_op BIND-CLICK" title="Mac Â∏ÉÂ±Ä">üçè</button>
    <button id="btn_showall" class="smbtn kb_op BIND-CLICK" title="ÊâÄÊúâÊò†Â∞Ñ">All</button>
    <span>&nbsp;ÈîÆÁõòÂ±Ç:</span>
    <div id="layer_btns"></div>
    <span>&nbsp;</span>
    <button id="btn_l_clr" class="btn danger BIND-CLICK">Ê∏ÖÁ©∫Êú¨Â±Ç</button>
    <span style="flex: 1;">&nbsp;</span>
</div>
<div id="tab_kb" class="tab">
    <keyboard id="kb_std">
        <kb_pc>
            <kb_main>
                <kr class="Fn">
                    <k>Esc</k><d> </d><k>F1</k><k>F2</k><k>F3</k><k>F4</k><d> </d><k>F5</k><k>F6</k><k>F7</k><k>F8</k><d> </d><k>F9</k><k>F10</k><k>F11</k><k>F12</k>
                </kr>
                <div></div>
                <kr>
                    <k>`</k><k>1</k><k>2</k><k>3</k><k>4</k><k>5</k><k>6</k><k>7</k><k>8</k><k>9</k><k>0</k><k>-</k><k>=</k><k class="k2">Backspace</k>
                </kr>
                <kr>
                    <k class="k15">Tab</k><k>Q</k><k>W</k><k>E</k><k>R</k><k>T</k><k>Y</k><k>U</k><k>I</k><k>O</k><k>P</k><k>[</k><k>]</k><k class="k15">\</k>
                </kr>
                <kr>
                    <k class="k2">Caps</k><k>A</k><k>S</k><k>D</k><k>F</k><k>G</k><k>H</k><k>J</k><k>K</k><k>L</k><k>;</k><k>'</k><k class="k2">Enter</k>
                </kr>
                <kr>
                    <k class="k25">Shift</k><k>Z</k><k>X</k><k>C</k><k>V</k><k>B</k><k>N</k><k>M</k><k>,</k><k>.</k><k>/</k><k class="k25">RShift</k>
                </kr>
                <kr>
                    <k class="k15">Ctrl</k><k class="k15">Win</k><k class="k15">Alt</k>
                    <k class="kspace">Space</k>
                    <k class="k15">RAlt</k><k class="k15">Menu</k><k class="k15">RCtrl</k>
                </kr>
            </kb_main>
            <kb_dir>
                <kr>
                    <k>PrtScr</k><k>ScrLck</k><k>Pause</k>
                </kr>
                <kr></kr>
                <kr>
                    <k>Ins</k><k>Home</k><k>PgUp</k>
                </kr>
                <kr>
                    <k>Del</k><k>End</k><k>PgDn</k>
                </kr>
                <kr> </kr>
                <kr>
                    <d> </d><k>Up</k><d> </d>
                </kr>
                <kr>
                    <k>Left</k><k>Down</k><k>Right</k>
                </kr>
            </kb_dir>
            <kb_num>
                <k>NumLck</k><k>Num/</k><k>Num*</k><k>Num-</k>
                <k>Num7</k><k>Num8</k><k>Num9</k><k class="k2v">Num+</k>
                <k>Num4</k><k>Num5</k><k>Num6</k>
                <k>Num1</k><k>Num2</k><k>Num3</k><k class="k2v">REnter</k>
                <k class="k2h">Num0</k><k>Num.</k>
            </kb_num>
        </kb_pc>
        <kb_mac>
            <kb_main>
                <kr>
                    <k class="kspace">esc</k><k>F1</k><k>F2</k><k>F3</k><k>F4</k><k>F5</k><k>F6</k><k>F7</k><k>F8</k><k>F9</k><k>F10</k><k>F11</k><k>F12</k><d class="k"> </d>
                </kr>
                <kr>
                    <k>`</k><k>1</k><k>2</k><k>3</k><k>4</k><k>5</k><k>6</k><k>7</k><k>8</k><k>9</k><k>0</k><k>-</k><k>=</k><k class="k15">del</k>
                </kr>
                <kr>
                    <k class="k15">tab</k><k>Q</k><k>W</k><k>E</k><k>R</k><k>T</k><k>Y</k><k>U</k><k>I</k><k>O</k><k>P</k><k>[</k><k>]</k><k>\</k>
                </kr>
                <kr>
                    <k class="kspace">caps</k><k>A</k><k>S</k><k>D</k><k>F</k><k>G</k><k>H</k><k>J</k><k>K</k><k>L</k><k>;</k><k>'</k><k class="kspace">return</k>
                </kr>
                <kr>
                    <k class="kspace">shift</k><k>Z</k><k>X</k><k>C</k><k>V</k><k>B</k><k>N</k><k>M</k><k>,</k><k>.</k><k>/</k><k class="kspace">r-shift</k>
                </kr>
                <kr>
                    <k class="k15">ctrl</k><k class="k13">opt</k><k class="k15">cmd</k>
                    <k class="kspace">Space</k>
                    <k class="k15">r-cmd</k><k class="k13">r-opt</k><k class="k15">r-ctrl</k>
                </kr>
            </kb_main>
            <kb_dir>
                <kr>
                    <k>F13</k><k>F14</k><k>F15</k>
                </kr>
                <kr>
                    <k>fn</k><k>home</k><k>pgup</k>
                </kr>
                <kr>
                    <k>fwd-del</k><k>end</k><k>pgdn</k>
                </kr>
                <kr> </kr>
                <kr>
                    <d> </d><k>Up</k><d> </d>
                </kr>
                <kr>
                    <k>Left</k><k>Down</k><k>Right</k>
                </kr>
            </kb_dir>
            <kb_num>
                <k>F16</k><k>F17</k><k>F18</k><k>F19</k>
                <k>clear</k><k>Num=</k><k>Num/</k><k>Num*</k>
                <k>Num7</k><k>Num8</k><k>Num9</k><k>Num-</k>
                <k>Num4</k><k>Num5</k><k>Num6</k><k>Num+</k>
                <k>Num1</k><k>Num2</k><k>Num3</k><k class="k2v">enter</k>
                <k class="k2h">Num0</k><k>Num.</k>
            </kb_num>
        </kb_mac>
    </keyboard>
    <keyboard id="kb_ext"></keyboard>
    <textarea id="comment" placeholder="Â§áÊ≥®"></textarea>
</div>
<div id="tab_list" class="tab">
    <div id="list"></div>
</div>
<div id="json_ops">
    &nbsp;JSON Êï∞ÊçÆÈöè‰∏äÂõæËÆæÁΩÆÂÆûÊó∂Êõ¥Êñ∞„ÄÇ‰πüÂèØÂú®‰∏ãÊñπÁºñËæë JSON Êï∞ÊçÆÂêéÔºö
    <button id="btn_imp" class="btn BIND-CLICK" style="margin: 2px;">ÂØºÂÖ•Ëá≥ÂΩìÂâçÈîÆË∞±</button>
    <button id="btn_imp2" class="btn BIND-CLICK" style="margin: 2px;">ÂØºÂÖ•Ëá≥Êñ∞ÈîÆË∞±</button>
</div>
<div id="tab_json" class="tab">
    <textarea id="json"></textarea>
</div>
<div class="about"></div>

<script>
const KEY_TABLE_COMMON = {
    // "0": [''], "1": [''], "2": [''], "3": [''], "4": [''], "5": [''], "6": [''], "7": [''], "8": [''], "9": [''],
    // "A": [''], "B": [''], "C": [''], "D": [''], "E": [''], "F": [''], "G": [''], "H": [''], "I": [''], "J": [''],
    // "K": [''], "L": [''], "M": [''], "N": [''], "O": [''], "P": [''], "Q": [''], "R": [''], "S": [''], "T": [''],
    // "U": [''], "V": [''], "W": [''], "X": [''], "Y": [''], "Z": [''],
    // ";": [''], "=": [''], ",": [''], "-": [''], ".": [''], "/": [''], "`": [''], "[": [''], "\\": [''], "]": [''], "'": [''],
    // "F1": [''], "F2": [''], "F3": [''], "F4": [''], "F5": [''], "F6": [''], "F7": [''], "F8": [''], "F9": [''], "F10": [''], "F11": [''], "F12": [''],
    // "Alt": [''], "RAlt": [''], "Backspace": [''], "Caps": [''], "Ctrl": [''], "RCtrl": [''], "Del": [''], "Down": ['‚Üì'], "End": [''], "Enter": [''], "REnter": [''], "Esc": [''],
    // "Home": [''], "Ins": [''], "Left": ['‚Üê'], "Menu": [''], "Pause": [''], "PgDn": [''], "PgUp": [''], "PrtScr": [''], "Right": ['‚Üí'],
    // "ScrLck": [''], "Shift": [''], "RShift": [''], "Space": [''], "Tab": [''], "Up": ['‚Üë'], "Win": [''],
    // "NumLck": [''], "Num-": ['-'], "Num*": ['*'], "Num.": ['.'], "Num/": ['/'], "Num+": ['+'],
    // "Num0": ['0'], "Num1": ['1'], "Num2": ['2'], "Num3": ['3'], "Num4": ['4'], "Num5": ['5'], "Num6": ['6'], "Num7": ['7'], "Num8": ['8'], "Num9": ['9'],
    // // "F13": [''], "F14": [''], "F15": [''], "F16": [''], "F17": [''], "F18": [''], "F19": [''], "F20": [''], "F21": [''], "F22": [''], "F23": [''], "F24": [''], "F25": [''], "F26": [''], "F27": [''], "F28": [''], "F29": [''], "F30": [''],
    // // "LB": [''], "RB": [''], "MB": [''], "WhlUp": [''], "WhlDn": [''],
    "0": '', "1": '', "2": '', "3": '', "4": '', "5": '', "6": '', "7": '', "8": '', "9": '',
    "A": '', "B": '', "C": '', "D": '', "E": '', "F": '', "G": '', "H": '', "I": '', "J": '',
    "K": '', "L": '', "M": '', "N": '', "O": '', "P": '', "Q": '', "R": '', "S": '', "T": '',
    "U": '', "V": '', "W": '', "X": '', "Y": '', "Z": '',
    ";": '', "=": '', ",": '', "-": '', ".": '', "/": '', "`": '', "[": '', "\\": '', "]": '', "'": '',
    "F1": '', "F2": '', "F3": '', "F4": '', "F5": '', "F6": '', "F7": '', "F8": '', "F9": '', "F10": '', "F11": '', "F12": '',
    "Up": '‚Üë', "Down": '‚Üì', "Left": '‚Üê', "Right": '‚Üí',
    "NumLck": '', "Num-": '-', "Num*": '*', "Num.": '.', "Num/": '/', "Num+": '+',
    "Num0": '0', "Num1": '1', "Num2": '2', "Num3": '3', "Num4": '4', "Num5": '5', "Num6": '6', "Num7": '7', "Num8": '8', "Num9": '9',
    "Space": '',
    // "F13": '', "F14": '', "F15": '', "F16": '', "F17": '', "F18": '', "F19": '', "F20": '', "F21": '', "F22": '', "F23": '', "F24": '', "F25": '', "F26": '', "F27": '', "F28": '', "F29": '', "F30": '',
    // "LB": '', "RB": '', "MB": '', "WhlUp": '', "WhlDn": '', 
};
const KEY_TABLE_PC = Object.assign({}, KEY_TABLE_COMMON, {
    "Esc": '', "Tab": '', "Shift": '', "RShift": '', "Backspace": '', "Caps": '', "Enter": '', "REnter": '',
    "Ins": '', "Del": '',  "Home": '', "End": '', "PgUp": '', "PgDn": '',
    "Alt": '', "RAlt": '', "Ctrl": '', "RCtrl": '', "Win": '', "Menu": '',
    "PrtScr": '', "ScrLck": '', "Pause": '',
});
const KEY_TABLE_MAC = Object.assign({}, KEY_TABLE_COMMON, {
    "esc": '', "del": 'delete', "tab": '', "caps": 'caps lock', "return": '', "shift": '', "r-shift": '',
    "ctrl": 'control', "opt": 'option', "cmd": 'command', "r-ctrl": 'r-control', "r-opt": 'r-option', "r-cmd": 'r-command',
    "fn": '', "home": '', "end": '', "pgup": 'page up', "pgdn": 'page down', "fwd-del": '[x&gt;',
    "clear": '', "enter": '', "Num=": '=',
    "F13": '', "F14": '', "F15": '', "F16": '', "F17": '', "F18": '', "F19": '', 
});
const KEY_TABLE_ALL = Object.assign({}, KEY_TABLE_COMMON, KEY_TABLE_PC, KEY_TABLE_MAC);
const MODKEYS_PC = ["Alt", "Ctrl", "Shift", "Win", "RAlt", "RCtrl", "RShift"];
const MODKEYS_MAC = ["opt", "ctrl", "shift", "cmd", "r-opt", "r-ctrl", "r-shift", "r-cmd", "fn"];
const MODKEY_COLORS = {
    "Alt": "#e53935",
    "Ctrl": "#00c853",
    "Shift": "#1976d2",
    "Win": "#7c4dff",
    "RAlt": "#e53935/",
    "RCtrl": "#00c853/",
    "RShift": "#1976d2/",
    "opt": "#e53935",
    "ctrl": "#00c853",
    "shift": "#1976d2",
    "cmd": "#7c4dff",
    "r-opt": "#e53935/",
    "r-ctrl": "#00c853/",
    "r-shift": "#1976d2/",
    "r-cmd": "#7c4dff/",
    "fn": "#ffc400"
};
const MODKEY_CHARS = {
    "Alt": "A",
    "Ctrl": "C",
    "Shift": "S",
    "Win": "W",
    "RAlt": "a",
    "RCtrl": "c",
    "RShift": "s",
    "opt": "o",
    "ctrl": "c",
    "shift": "s",
    "cmd": "m",
    "r-opt": "O",
    "r-ctrl": "C",
    "r-shift": "S",
    "r-cmd": "M",
    "fn": "f"
};
const KEY_GROUP_COLORS = {
    "g1": "#ACE1AF",
    "g2": "#F7CAC9",
    "g3": "#E7E28C",
    "g4": "#BFBD50",
    "g5": "#DCAE96",
    "g6": "#FAA052",
    "g7": "#8ED449",
    "g8": "#F2CB07",
    "g9": "#BBBBBB",
};

var Util = {
    split_combo(combo_str) {
        let l = combo_str.replaceAll("Num+", "NumPlus").replaceAll("+", "_+_").replaceAll("NumPlus", "Num+").split("_+_");
        let mk = l.pop();
        l.sort();
        l.push(mk);
        return l;
    },

    get_mainkey(combo_str) {
        let l = this.split_combo(combo_str);
        return l[l.length - 1];
    },

    normalize_combo(combo_str) {
        return Util.split_combo(combo_str).join("+");
    },

    between(v, min, max) {
        return (v < min) ? min : ((v > max) ? max : v);
    },

    is_empty_obj(obj) {
        for (const v in obj) return false;
        return true;
    },

    patch_obj(dst, src) {
        for (const k in src) {
            if (!(k in dst))
                dst[k] = src[k];
        }
    },

    gen_combo_kn_elm(kn) {
        let ck = this.split_combo(kn);
        let mk = ck.pop();
        let l = [];
        for (const k of ck) {
            let clr = Keymap.getModColor(k) || ["transparent", "transparent"];
            l.push(`<kn data-k="${k}" class="ck ${Keymap.ModKeyColorMode?'mod_color':''} mod_${Keymap.ModKeyMode}" style="${clr[0]?'--mod-c1:'+clr[0]+';':''}${clr[1]?'--mod-c2:'+clr[1]+';':''}">${k}</kn>`);
        }
        // group color
        let g = "";
        let c = "";
        if (Keymap.GroupMode) {
            g = "group";
            let info = Keymap.getMapping(kn);
            if (info) {
                let l = info.trim().split("\n").pop();
                c = l.startsWith("::") ? `--gc: ${Keymap.getGroupColor(l.substr(2))};` : "";
            }
        }
        l.push(`<kn data-k="${mk}">${mk}</kn>`)
        return `<span data-mainkey="${mk}" data-combo="${kn}" class="kinfo f-end combo ${g}" style="${c}">${l.join("+")}</span>`;
    },
};

const NEW_KEYMAP = "+ Êñ∞Âª∫";
const HELP_KEYMAP = "* Â∏ÆÂä©";
const HELP = `„ÄêÂ§áÊ≥®„ÄëËøôÈáåÊòØÂ§áÊ≥®Ê°ÜÔºåÂèØ‰ª•‰∏∫ÊØè‰∏™ÈîÆÁõòÂ±ÇÂ§áÊ≥®‰ø°ÊÅØ„ÄÇ

„ÄêËØïÈ™å„ÄëËøôÊòØ‰∏Ä‰∏™ËôöÊãüÁöÑÈîÆË∞±Ôºå‰Ω†ÂèØ‰ª•Âú®ËøôÈáåËØïÈ™åÂêÑÁßçÊìç‰ΩúÔºåÈáçÊñ∞ËΩΩÂÖ•‚Äú${HELP_KEYMAP}‚ÄùÂç≥ÂèØÊÅ¢Â§çÂéüÊ†∑„ÄÇ

„ÄêÂ∏ÆÂä©„ÄëÔºàÂ±Ç 1 ÊúâÊõ¥Â§öÂ∏ÆÂä©ÔºåÊåâ 1 ÂàáÊç¢Ôºâ
  * ÁÇπÂáªÈ°∂ÈÉ®ÁöÑ‚ÄúÈîÆË∞±Âêç‚ÄùÔºåÂèØ‰ª•Êñ∞Âª∫ÂíåÂàáÊç¢ÈîÆË∞±„ÄÇ
  * ÁÇπÂáªÈîÆÁõòÂõæ‰∏≠ÁöÑÊåâÈîÆÔºåÂèØ‰ª•ÂΩïÂÖ•ÊåâÈîÆÊò†Â∞Ñ‰ø°ÊÅØ„ÄÇ
  * ÁªÑÂêàÈîÆÔºöÂú®ÂΩïÂÖ•Êó∂ÂèØ‰ª•ÈÄâÊã©ÁªÑÂêà‰øÆÈ•∞ÈîÆÔºàAlt„ÄÅCtrl„ÄÅShift„ÄÅWin ...Ôºâ„ÄÇ
  * ‰∏Ä‰∏™ÊåâÈîÆ‰∏äÂèØ‰ª•ÂΩïÂÖ•Â§öÁªÑÁªÑÂêàÈîÆ„ÄÇ
  * Êò†Â∞Ñ‰ø°ÊÅØ‰ª•"* "ÔºàÊòüÂè∑+Á©∫Ê†ºÔºâÂºÄÂ§¥ÁöÑÁªÑÂêàÈîÆÂÆö‰πâ‰∏∫‰∏ªÊò†Â∞ÑÔºåÂú®‚ÄúÈîÆÂ∏ΩÊèêÁ§∫‚ÄùÊ®°Âºè‰∏ã‰ºöÂú®ÈîÆÂ∏Ω‰∏äÊòæÁ§∫Á¨¨‰∏ÄË°åÊñáÂ≠óÔºåÂπ∂‰∏î‰∏ªÊò†Â∞ÑÁöÑÁªÑÂêàÈîÆ‰ºöÁõ¥Êé•ÊòæÁ§∫Âú®ÈîÆÂ∏Ω‰∏ä„ÄÇ
  * ÂèØ‰ª•Ëá™ÂÆö‰πâÊâ©Â±ïÈîÆ„ÄÅ‰øÆÈ•∞ÈîÆ„ÄÇ
  * ÂèØ‰ª•ËÆæÁΩÆÈîÆÁõòÂ±ÇÊï∞ÔºåÊó†‰∏äÈôêÔºàÂóØÔºåÂ§ßÊ¶ÇÂêßÔºâÔºåÂèØ‰ª•Ëá™ÂÆö‰πâÈîÆÁõòÂ±ÇÂêç„ÄÇ
  * ÊØè‰∏™ÈîÆË∞±ÁöÑÂΩìÂâçÁä∂ÊÄÅÈÉΩ‰ºöÂÆûÊó∂‰øùÂ≠òÔºàÈô§‰∫Ü‚ÄúÂΩìÂâçÈîÆÁõòÂ±Ç‚ÄùÔºâÔºåÂú®‰∏ãÊ¨°ÊâìÂºÄÊó∂‰ºöËá™Âä®ÊÅ¢Â§ç„ÄÇÂõ†Ê≠§ÔºåÂèØ‰ª•‰∏∫ÊØè‰∏™ÈîÆË∞±ËÆæÁΩÆ‰∏çÂêåÁöÑÊòæÁ§∫È£éÊ†º„ÄÇ

„ÄêË∞±Âå£„ÄëÈÄöËøáË∞±Âå£Á®ãÂ∫è‰ΩøÁî®ÈîÆË∞±Êó∂ÔºåÂèØ‰ª•‰ΩøÁî®ÂëΩ‰ª§Ë°åÂèÇÊï∞Ëá™ÂÆö‰πâËΩΩÂÖ•ÁöÑÈîÆË∞±ÂèäÁïåÈù¢„ÄÇ‰∏çÈúÄÊèê‰æõÊâÄÊúâÂèÇÊï∞ÔºåÊú™Êèê‰æõÁöÑÂèÇÊï∞‰ºöÊåâÈîÆË∞±‰∏≠‰øùÂ≠òÁöÑÁä∂ÊÄÅÊòæÁ§∫„ÄÇ
  -P ÈîÆË∞±Âêç
  -L ÈîÆÁõòÂ±Ç : [0~9]
  -V ËßÜÂõæ : [k/l/j] ÈîÆÂõæ / ÈîÆË°® / Êï∞ÊçÆ
  -S ‰∏ªÈîÆÁõòÂ§ßÂ∞è : [0~3] ÈöêËóè / 60% / 80% / Ê†áÂáÜ
  -X Êâ©Â±ïÈîÆÂå∫ Ôºö[0/1] ÂÖ≥Èó≠ / ÊâìÂºÄ
  -H ÈîÆÂ∏ΩÊèêÁ§∫ : [0/1] ÂÖ≥Èó≠ / ÊâìÂºÄ
  -M ÁïåÈù¢Ê®°Âºè : [t/s] ÂàÜÈ°µ / ÂçïÈ°µ
  Á§∫‰æãÔºöÊâìÂºÄÈîÆË∞±‚ÄúPhotoshop‚ÄùÔºåÂàáÊç¢Âà∞Â±Ç2ÔºåÊòæÁ§∫ÈîÆÂõæÔºå60%ÈîÆÁõòÂ§ßÂ∞èÔºåÂÖ≥Èó≠Êâ©Â±ïÈîÆÂå∫ÔºåÊâìÂºÄÈîÆÂ∏ΩÊèêÁ§∫ÔºåÂçïÈ°µÊ®°Âºè„ÄÇ
    keymap.exe -P Photoshop -L 2 -V k -S 1 -X 0 -H 1 -M s

„ÄêÂΩ©Ëõã„ÄëÂè≥‰∏äÁöÑ‚ÄúÁÆÄÂçï‚Äù‰∏çÁÆÄÂçï ;-)
`;
const HELP1 = `ÊåáÂêëÂêÑ‰∏™ÊåâÈîÆÂèØ‰ª•ÁúãÂà∞‰∏çÂêå‰ø°ÊÅØ„ÄÇ

* ÈîÆÁõòÂ∏ÉÂ±ÄÔºöÊåâ m / Shift+m ÂàáÊç¢Â∏ÉÂ±Ä
  PC Âíå Mac Êúâ‰∫õÈîÆÊòØ‰∏çÂêåÁöÑÔºåÂü∫Êú¨‰∏äÈô§Â≠óÊØçÈîÆ„ÄÅFnÈîÆÂ§ñÁöÑÈîÆÈÉΩ‰∏çÂêå„ÄÇ

* ÊâÄÊúâÊò†Â∞ÑÔºöÊåâ f / Shift+f ÂºÄÂÖ≥
  ÊòæÁ§∫/ÈöêËóè ÂåÖÂê´‚ÄúÈùûÊú¨ÈîÆÁõòÊåâÈîÆ‚ÄùÁöÑÊò†Â∞Ñ‰ø°ÊÅØ
  ÂΩìÁªÑÂêàÈîÆ‰∏≠ÂåÖÂê´Êúâ‚ÄúÈùûÊú¨ÈîÆÁõòÊåâÈîÆ‚ÄùÊó∂ÔºåÂèóÊú¨ÂºÄÂÖ≥ÊéßÂà∂„ÄÇ
  ÂèóÂΩ±ÂìçÔºöÈîÆË°® / Êò†Â∞Ñ‰ø°ÊÅØËÆæÁΩÆÊó∂ÁöÑ‰øÆÈ•∞ÈîÆÂàóË°® / ÊåáÂêëÊåâÈîÆÊó∂ÊòæÁ§∫ÁöÑÊò†Â∞Ñ‰ø°ÊÅØ

* Ëá™ÂÆö‰πâÊâ©Â±ïÈîÆÔºö
  * ÈîÆÂêç‰ª•Ëã±ÊñáÈÄóÂè∑(,)ÂàÜÈöî
  * ‰ª• "#" ÂºÄÂ§¥ÁöÑ‰ºö‰ª•Á∫ØÊñáÂ≠óÊòæÁ§∫
  * Âçï‰∏™ "#" ÊòæÁ§∫‰∏Ä‰∏™ÈîÆ‰ΩçÂ§ßÂ∞èÁöÑÁ©∫ÁôΩ
  * ÊîØÊåÅÊç¢Ë°åÔºåÊØèË°å‰ª£Ë°®‰∏ÄË°åÊâ©Â±ïÈîÆ
  * ‰∏çÂê´Êâ©Â±ïÈîÆÁöÑË°å‰ºöÂøΩÁï•ÔºàÂåÖÊã¨Á©∫Ë°åÂíåÂè™ÊúâÈÄóÂè∑ÁöÑË°åÔºâ

* Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆÔºö
  * ÊØè‰∏™ÈîÆÂêç‰ª•Ëã±ÊñáÈÄóÂè∑(,)ÂàÜÈöî
  * Ëé∑ÂèñÈîÆÂêçÔºöÈº†Ê†áÁÇπÂáªÊåâÈîÆÔºåÂºπÂá∫ÁöÑËÆæÁΩÆÊò†Â∞Ñ‰ø°ÊÅØÂØπËØùÊ°ÜÂÜÖÂ∑¶‰∏äËßí
  * ÊîØÊåÅ‰ΩøÁî®Êâ©Â±ïÈîÆ‰Ωú‰∏∫‰øÆÈ•∞ÈîÆ
  * ÁîöËá≥ÂèØ‰ª•ÊåáÂÆö‰∏çÂ≠òÂú®ÁöÑÈîÆÂêç‰Ωú‰∏∫‰øÆÈ•∞ÈîÆÔºö
    ËøôÁßç‰øÆÈ•∞ÈîÆÂè™Âú®‚ÄúÊâÄÊúâÊò†Â∞Ñ‚ÄùÂºÄÂÖ≥ÊâìÂºÄÊó∂Êâç‰ΩøÁî®ÔºåÂåÖÂê´ËøôÁßç‰øÆÈ•∞ÈîÆÁöÑÊò†Â∞Ñ‰ø°ÊÅØ‰πüÂè™Âú®‚ÄúÊâÄÊúâÊò†Â∞Ñ‚ÄùÂºÄÂÖ≥ÊâìÂºÄÊó∂ÊâçÂèØËßÅ

* Á≠õÈÄâÔºö
  * Âè≥ÈîÆÁÇπÂáªÊåâÈîÆÔºåÂèØ‰ª•Á≠õÈÄâÂåÖÂê´ËØ•ÈîÆÁöÑÁªÑÂêàÈîÆ
  * Êåâ‰Ωè \"Ctrl\" ÂèØÂêåÊó∂ÈÄâÊã©Â§ö‰∏™ÈîÆËøõË°åÁ≠õÈÄâÔºåÁªìÊûú‰∏∫ÂêåÊó∂ÂåÖÂê´Ëøô‰∫õÈîÆÁöÑÁªÑÂêàÈîÆ
`;
const HELP2 = `„ÄêÂàÜÁªÑ„Äë
  * ÂàÜÁªÑÊñπÊ≥ïÔºöÁªÑÂêàÈîÆÊò†Â∞Ñ‰ø°ÊÅØÁöÑÊúÄÊú´Ë°å‰ª•‰∏§‰∏™ÂºïÂè∑ "::" ÂºÄÂ§¥ÔºåÂêéÊé•ÁªÑÂêç
  * ÈúÄË¶ÅÂú®ËÆæÁΩÆ‰∏≠ÂêØÁî®‚ÄúÂàÜÁªÑÈ¢úËâ≤‚Äù
  * ÂêØÁî®ÂêéÔºåÈîÆÂ∏ΩÊòæÁ§∫‰∏ªÊò†Â∞ÑÁöÑÂàÜÁªÑÈ¢úËâ≤ÔºåÊó†‰∏ªÊò†Â∞ÑÊàñÊú™ÂàÜÁªÑÁöÑÈîÆÂ∏ΩÊòæÁ§∫Êú™ÂàÜÁªÑÈ¢úËâ≤
  * ÂêØÁî®ÂêéÔºåÈîÆË°®‰∏≠ÁöÑÊò†Â∞ÑÁªÑÂêàÈîÆ‰πü‰ºö‰ª•ÂàÜÁªÑÈ¢úËâ≤‰∏∫ËÉåÊôØËâ≤
  * Ëá™ÂÆö‰πâÂàÜÁªÑÈ¢úËâ≤Ôºö"ÁªÑÂêç1::È¢úËâ≤ÂÄº1, ÁªÑÂêç2::È¢úËâ≤ÂÄº2, ..."
  * ÂèØ‰ª•‰øÆÊîπÊú™ÂàÜÁªÑÈ¢úËâ≤ÔºåËÆæÁΩÆÁªÑÂêç‰∏∫Á©∫ÁöÑËá™ÂÆö‰πâÈ¢úËâ≤Ôºö"::È¢úËâ≤ÂÄº"

„Äê‰øÆÈ•∞ÈîÆ„Äë
  * Â¶ÇÊûú‰∏Ä‰∏™ÈîÆ‰∏äÊúâ‰∏ªÊò†Â∞ÑÔºåÈÇ£‰πàËØ•ÁªÑÂêàÈîÆÁöÑÊâÄÊúâ‰øÆÈ•∞ÈîÆ‰ºöÂêåÊó∂ÊòæÁ§∫Âú®ÈîÆÂ∏Ω‰∏ä
  * ÈîÆÂ∏Ω‰∏ä‰øÆÈ•∞ÈîÆÁöÑÊòæÁ§∫Ê®°ÂºèÊúâ‰∏âÁßçÔºö
    * ÈîÆÂêçÔºö‰øÆÈ•∞ÈîÆÁöÑÈîÆÂêç
    * Áº©ÂÜôÔºöÈîÆÂêçÁöÑÁº©ÂÜôÔºå‰∏ÄËà¨‰∏∫‰∏Ä‰∏™Â≠óÊØç
    * ‰ªÖÈ¢úËâ≤ÔºöÂêØÁî®‰øÆÈ•∞ÈîÆÈ¢úËâ≤ÂêéÔºåÊòæÁ§∫‰øÆÈ•∞ÈîÆÂØπÂ∫îÈ¢úËâ≤ÁöÑÂ∞èÊñπÂùó
  * Ëá™ÂÆö‰πâÁº©ÂÜôÔºöÈîÆÂêç1::Áº©ÂÜô1, ÈîÆÂêç2::Áº©ÂÜô2, ...
    ÂØπÊú™ËÆæÁΩÆÁº©ÂÜôÁöÑ‰øÆÈ•∞ÈîÆÔºåÈªòËÆ§‰∏∫ÈîÆÂêçÈ¶ñÂ≠óÊØç
  * Ëá™ÂÆö‰πâÈ¢úËâ≤ÔºöÈîÆÂêç1::È¢úËâ≤1, ÈîÆÂêç2::È¢úËâ≤2, ...
    È¢úËâ≤ÊîØÊåÅ‰∏§ÁßçÊ†ºÂºèÔºöÈ¢úËâ≤ÂÄºÔºåÂ∑¶‰∏äÈ¢úËâ≤ÂÄº/Âè≥‰∏ãÈ¢úËâ≤ÂÄº
    * ÂçïËâ≤Ê†ºÂºèÔºö
      Êï¥‰∏™‰øÆÈ•∞ÈîÆ‰∏ÄÁßçËÉåÊôØËâ≤
    * ÂèåËâ≤Ê†ºÂºèÔºö
      ‰øÆÈ•∞ÈîÆÁöÑËÉåÊôØËâ≤Áî± Â∑¶‰∏ä/Âè≥‰∏ã ‰∏§‰∏™È¢úËâ≤ÁªÑÂêàÔºåÂêÑÂç† 50%
      È¢úËâ≤ÂèØ‰ª•‰∏∫Á©∫Ôºå‰∏∫Á©∫ÈÉ®ÂàÜ‰∏∫ÁôΩËâ≤Ôºå‰∏îÂç†ÊØîÁº©Â∞è‰∏∫ 20%
  * ÂêØÁî®‰øÆÈ•∞ÈîÆÈ¢úËâ≤ÂêéÔºåÊâÄÊúâ‰øÆÈ•∞ÈîÆÊòæÁ§∫Âùá‰ºö‰ΩøÁî®ÂÆö‰πâÁöÑËÉåÊôØÈ¢úËâ≤
    ÂØπÊú™ËÆæÁΩÆÈ¢úËâ≤ÁöÑ‰øÆÈ•∞ÈîÆÔºåÈªòËÆ§‰∏∫ÈÄèÊòéËÉåÊôØ
  * È¢úËâ≤ÂíåÊòæÁ§∫Ê®°ÂºèÂèØ‰ª•ÈöèÊÑèÁªÑÂêà
`;
const KeymapHelp = {
    "#NAME": HELP_KEYMAP,
    "#config": {
        "layout": "pc",
        "view": "k",
        "kbsize": 1,
        "kbext": true,
        "kbhint": true,
        "extkeys": ["#Èº†Ê†á", "LB", "RB", "MB", "WhlUp", "WhlDn", "#Êâ©Â±ï", "XK1", "XK2", "XK3", "XK4",
                    "__CR/LF__", "#Fn", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20",
                    ],
        "modkeys": ["Caps", "caps", "XK1"],
        "modkey_mode": "chr",
        "modkey_clr": true,
        "layer_names": {
            "#0": "Â∏ÆÂä©",
            "#1": "Êõ¥Â§ö",
            "#2": "ÂàÜÁªÑ„ÄÅ‰øÆÈ•∞ÈîÆ„ÄÅÈ¢úËâ≤",
        },
        "group": true,
    },
    "#0": {
        "`": "* ÈîÆÁõòÂ±Ç 0",
        "1": "* ÈîÆÁõòÂ±Ç 1\n::g1",
        "2": "* ÈîÆÁõòÂ±Ç 2\n::g2",
        "3": "* ÈîÆÁõòÂ±Ç 3",
        "4": "* ÈîÆÁõòÂ±Ç 4",
        "5": "* ÈîÆÁõòÂ±Ç 5",
        "6": "* ÈîÆÁõòÂ±Ç 6",
        "7": "* ÈîÆÁõòÂ±Ç 7",
        "8": "* ÈîÆÁõòÂ±Ç 8",
        "9": "* ÈîÆÁõòÂ±Ç 9",
        "Q": "* 60% ÈîÆÁõò",
        "W": "* 80% ÈîÆÁõò",
        "E": "* Ê†áÂáÜÈîÆÁõò",
        "R": "* ÈöêËóè‰∏ªÈîÆÁõò",
        "X": "* ÊòæÁ§∫Êâ©Â±ïÈîÆÂå∫",
        "Shift+X": "ÈöêËóèÊâ©Â±ïÈîÆÂå∫",
        "shift+X": "ÈöêËóèÊâ©Â±ïÈîÆÂå∫",
        "Tab": "* ÂºÄÂêØÈîÆÂ∏ΩÊèêÁ§∫\n  Âú®ÈîÆÂ∏Ω‰∏äÊòæÁ§∫‰∏ªÊò†Â∞Ñ‰ø°ÊÅØ",
        "Shift+Tab": "ÂÖ≥Èó≠ÈîÆÂ∏ΩÊèêÁ§∫",
        "tab": "* ÂºÄÂêØÈîÆÂ∏ΩÊèêÁ§∫\n  Âú®ÈîÆÂ∏Ω‰∏äÊòæÁ§∫‰∏ªÊò†Â∞Ñ‰ø°ÊÅØ",
        "shift+Tab": "ÂÖ≥Èó≠ÈîÆÂ∏ΩÊèêÁ§∫",
        "K": "* ‚ÄúÈîÆÂõæ‚ÄùÈ°µ",
        "L": "* ‚ÄúÈîÆË°®‚ÄùÈ°µ",
        ";": "* ‚ÄúÊï∞ÊçÆ‚ÄùÈ°µ",
        "P": "* ÂçïÈ°µÊ®°Âºè\n  Â∞ÜÈîÆÂõæÂíåÈîÆË°®ÊòæÁ§∫Âú®‰∏Ä‰∏™ÈïøÈ°µÈù¢ÂÜÖÔºåÁÆÄÂåñÈ°µÈù¢ÔºåÈöêËóèÊìç‰ΩúÂè∞Ôºà‰ª•‰æøÊâìÂç∞Ôºâ",
        "Shift+P": "ÂàÜÈ°µÊ®°Âºè\n  Â∞ÜÈîÆÂõæÂíåÈîÆË°®ÊòæÁ§∫Âú®‰∏çÂêåÂàÜÈ°µÔºåÊèê‰æõÂÆåÊï¥Êìç‰ΩúÁïåÈù¢",
        "shift+P": "ÂàÜÈ°µÊ®°Âºè\n  Â∞ÜÈîÆÂõæÂíåÈîÆË°®ÊòæÁ§∫Âú®‰∏çÂêåÂàÜÈ°µÔºåÊèê‰æõÂÆåÊï¥Êìç‰ΩúÁïåÈù¢",
        "M": "* MacÈîÆÁõòÂ∏ÉÂ±Ä",
        "Shift+M": "PCÈîÆÁõòÂ∏ÉÂ±Ä",
        "shift+M": "PCÈîÆÁõòÂ∏ÉÂ±Ä",
        "F": "* ÊòæÁ§∫ÂÖ®ÈÉ®Êò†Â∞Ñ\n  ÊòæÁ§∫ ÂåÖÂê´‚ÄúÈùûÊú¨ÈîÆÁõòÊåâÈîÆ‚ÄùÁöÑÊò†Â∞Ñ‰ø°ÊÅØ\n  ÂΩìÁªÑÂêàÈîÆ‰∏≠ÂåÖÂê´Êúâ‚ÄúÈùûÊú¨ÈîÆÁõòÊåâÈîÆ‚ÄùÊó∂ÔºåÂèóÊú¨ÂºÄÂÖ≥ÊéßÂà∂„ÄÇ",
        "Shift+F": "ÂÖ≥Èó≠ÊòæÁ§∫ÂÖ®ÈÉ®Êò†Â∞Ñ",
        "shift+F": "ÂÖ≥Èó≠ÊòæÁ§∫ÂÖ®ÈÉ®Êò†Â∞Ñ",
        "F2": "* ÈîÆÁõòÂ±ÇÊîπÂêç\n  ‰πüÂèØ‰ª•ÂèåÂáªÈîÆÁõòÂ±ÇÂêçËøõË°å‰øÆÊîπ",
        "LB": "* ËÆæÁΩÆÊò†Â∞Ñ",
        "RB": "* Á≠õÈÄâÊò†Â∞Ñ\n  ÈîÆÂõæÔºöÁ™ÅÂá∫ÊòæÁ§∫ÁªÑÂêàÈîÆ‰∏≠ÂåÖÂê´ÈÄâ‰∏≠ÈîÆÁöÑÈÇ£‰∫õÈîÆÂ∏Ω\n  ÈîÆË°®ÔºöÂè™ÊòæÁ§∫ÈÄâ‰∏≠ÈîÆÁõ∏ÂÖ≥ÁöÑÊò†Â∞Ñ‰ø°ÊÅØ\n  Êåâ p ÂàáÊç¢Âà∞ÂçïÈ°µÊ®°ÂºèÂêé‰ºöÊúâÊõ¥Áõ¥ËßÇÁöÑÊÑüÂèó",
        "Ctrl+RB": "Â§öÈîÆÁ≠õÈÄâ\nÂèØÂêåÊó∂ÈÄâÊã©Â§ö‰∏™ÈîÆËøõË°åÁ≠õÈÄâÔºåÁªìÊûú‰∏∫ÂêåÊó∂ÂåÖÂê´Ëøô‰∫õÈîÆÁöÑÁªÑÂêàÈîÆ",
        "Ctrl+O": "* ‰ªéÊñá‰ª∂ËΩΩÂÖ•",
        "Ctrl+S": "* ‰øùÂ≠òËá≥Êñá‰ª∂",
        "Ctrl+P": "ÁîüÊàêÂçïÈ°µÊ®°ÂºèÂõæÁâá",
        "#comment": HELP
    },
    "#1": {
        "Space": "* Â§öÁªÑÊò†Â∞Ñ",
        "Alt+Space": "ÁªÑÂêàÈîÆ1(PC)",
        "Alt+Shift+Space": "ÁªÑÂêàÈîÆ2(PC)",
        "opt+Space": "ÁªÑÂêàÈîÆ3(Mac)",
        "opt+shift+Space": "ÁªÑÂêàÈîÆ4(Mac)",
        "XK1": "* Ëá™ÂÆö‰πâÊâ©Â±ïÈîÆ",
        "Caps+A": "* Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆ(PC)\n  ÂèØ‰ª•Âú®ËÆæÁΩÆ‰∏≠Â¢ûÂä†Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆ„ÄÇ",
        "caps+A": "* Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆ(Mac)\n  ÂèØ‰ª•Âú®ËÆæÁΩÆ‰∏≠Â¢ûÂä†Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆ„ÄÇ",
        "Tab": "* ËøôÊòØ PC Â∏ÉÂ±Ä",
        "tab": "* ËøôÊòØ Mac Â∏ÉÂ±Ä",
        "Win": "* ËøôÊòØ PC Â∏ÉÂ±Ä",
        "opt": "* ËøôÊòØ Mac Â∏ÉÂ±Ä",
        "XK1+Z": "* Êâ©Â±ïÈîÆÂÅö‰øÆÈ•∞ÈîÆ",
        "#comment": HELP1
    },
    "#2": {
        "Alt+1": "* Êú™ÂàÜÁªÑ",
        "Ctrl+Q": "* Êú™ÂàÜÁªÑ ‚Ä¶",
        "Shift+A": "* Êú™ÂàÜÁªÑ",
        "Win+Z": "* Êú™ÂàÜÁªÑ",
        "Alt+Ctrl+3": "* ÁªÑ1\n::g1",
        "Ctrl+Shift+E": "ÁªÑ1Ôºå‰ΩÜ‰∏çÊòØ‰∏ªÊò†Â∞ÑÔºåÊâÄ‰ª•ÈîÆÂ∏Ω‰∏çÊòæÁ§∫ÂàÜÁªÑËâ≤\n::g1",
        "Shift+Win+D": "* ÁªÑ1 ‚Ä¶\n::g1",
        "RAlt+Win+C": "* ÁªÑ1\n::g1",
        "Alt+Ctrl+Shift+5": "* ÁªÑ2\n::g2",
        "Ctrl+Shift+Win+T": "* ÁªÑ2 ‚Ä¶\n::g2",
        "RAlt+Shift+Win+G": "* ÁªÑ2\n::g2",
        "RAlt+RCtrl+Win+B": "* ÁªÑ2\n::g2",
        "Ctrl+RShift+D": "ÁªÑ3Ôºå‰ΩÜ‰∏çÊòØ‰∏ªÊò†Â∞Ñ\n::g3",
        "Ctrl+Shift+Q": "ÁªÑ1Ôºå‰ΩÜ‰∏çÊòØ‰∏ªÊò†Â∞ÑÔºåÊâÄ‰ª•ÈîÆÂ∏Ω‰∏çÊòæÁ§∫ÂàÜÁªÑËâ≤\n::g1",
        "RCtrl+Shift+Win+T": "ÁªÑ4\n::g4",
        "Ctrl+RShift+Win+T": "ÁªÑ5\n::g5",
        "#comment": HELP2
    },
};

var Keymap = {
    Name: "",
    _data: null,
    _version: "",
    _cur_layer: 0,
    _virtual: false,

    _keytable: {},
    _extkeys: [],

    _filterkeys: [],

    _default_cfg: {
        "uimode": "tab",
        "layout": "pc",
        "layers": 10,
        "view": "k",
        "kbsize": 2,
        "kbext": false,
        "kbhint": false,
        "showall": false,
        "ks1": 0.75,
        "kw1": 3,
        "kh1": 3,
        "ks2": 0.9,
        "kw2": 5,
        "kh2": 5,
        "kt2": 0.75,
        "c0": "black",
        "c1": "lightblue",
        "c2": "lightseagreen",
        "c3": "black",
        "c4": "#e0e0e0",
        "cols": 2,
        "extkeys": [],
        "modkeys": [],
        "modkey_colors": MODKEY_COLORS, // {},
        "modkey_chars": MODKEY_CHARS, // {},
        "modkey_mode": "raw", // "raw", "chr", "dot",
        "modkey_clr": false,
        "layer_names": {},
        "group": false,
        "group_colors": KEY_GROUP_COLORS, // {},
    },

    get DefaultCfg() {
        return JSON.parse(JSON.stringify(this._default_cfg));
    },

    resetConfig() {
        Object.assign(this.Config, this.DefaultCfg);
    },

    get _default_keymap() {
        return JSON.parse(`{"#version": "${this._version}", "#config": ${JSON.stringify(this._default_cfg)}, "#0":{}}`);
    },

    init(name = "") {
        this.Name = name;
        this._data = this._default_keymap;
        this._cur_layer = 0;
        this._virtual = false;
        this._filterkeys = [];
    },

    _normalizeData(src) {
        let data = this._default_keymap;
        // ver 1 -> 2
        for (const k in src) {
            if (!src[k]) continue;
            if (k.toLowerCase() == "#config") {
                Object.assign(data["#config"], src[k]);
            } else if (k[0] != "#") {
                data["#0"][k] = src[k];
            } else {
                data[k] = src[k];
            }
        }
        // normalize combo keys
        for (let i=0; i<data["#config"]["layers"]; i++) {
            let s = data["#"+i];
            let d = {};
            for (const n in s) {
                if (n[0] == "#")
                    d[n] = s[n];
                else
                    d[Util.normalize_combo(n)] = s[n];
            }
            delete data["#"+i];
            data["#"+i] = d;
        }
        data["#version"] = this._version;
        return data;
    },

    loadJSON(json_str) {
        if (!json_str)
            return false;
        let temp = null;
        try {
            temp = JSON.parse(json_str);
            // this.fixStruct(temp);
        } catch (e) {
            console.log(e);
            return false;
        }
        // this._data = this._default_keymap;
        // for (const k in temp) {
        //     if (!temp[k]) continue;
        //     if (k.toLowerCase() == "#config") {
        //         Object.assign(this.Config, temp[k]);
        //     } else if (k[0] != "#") {
        //         this.LayerData(0)[k] = temp[k];
        //     } else {
        //         this._data[k] = temp[k];
        //     }
        // }
        this._data = this._normalizeData(temp);
        return true;
    },

    clear() {
        this._data = this._default_keymap;
        this._cur_layer = 0;
        this._filterkeys = [];
    },

    shrink() {
        for (const k in this._data) {
            if (!this._data[k] || Util.is_empty_obj(this._data[k])) {
                delete this._data[k];
            } else {
                for (let i=0; i<this.Config.layers; i++) {
                    if (!(("#"+i) in this._data)) continue;
                    for (const kk in this.LayerData(i)) {
                        if (!this.LayerData(i)[kk]) delete this.LayerData(i)[kk];
                    }
                }
            }
        }
    },

    get JSON() {
        return JSON.stringify(this._data, null, 2);
    },

    get Config() {
        return this._data["#config"];
    },

    get KBSize() {
        return Util.between(this.Config.kbsize, 0, 3);
    },

    set KBSize(v) {
        this.Config.kbsize = Util.between(v, 0, 3);
    },

    get CurLayer() {
        return this._cur_layer;
    },

    set CurLayer(ln) {
        this.checkLayer(ln);
        this._cur_layer = ln;
    },

    checkLayer(ln) {
        if (ln < 0 || ln >= this.Config.layers) {
            throw RangeError("Layer # error: " + ln);
        }
    },

    LayerData(ln = null) {
        if (ln == null)
            ln = this.CurLayer;
        this.checkLayer(ln);
        if (!(("#"+ln) in this._data))
            this._data["#"+ln] = {}
        return this._data["#"+ln];
    },

    clearLayer(ln = null) {
        if (ln == null)
            ln = this.CurLayer;
        this.checkLayer(ln);
        this._data["#"+ln] = {};
    },

    getLayerName(ln = null) {
        if (ln == null)
            ln = this.CurLayer;
        return (this.Config.layer_names["#"+ln] || "");
    },

    getLayerPrintName(ln = null) {
        if (ln == null)
            ln = this.CurLayer;
        let layerName = this.getLayerName(ln);
        return `${this.Name}_L${ln}${layerName ? "_"+layerName : ""}`;
    },

    //Rename layer
    setLayerName(name, ln = null) {
        if (ln == null)
            ln = this.CurLayer;
        this.Config["layer_names"]["#"+ln] = name;
    },

    getMapping(kn, ln = null) {
        return this.LayerData(ln)[Util.normalize_combo(kn)] || null;
    },

    getAllMappings(mk, ln = null) {
        let ret = {};
        for (const kn in this.LayerData(ln)) {
            if (Util.get_mainkey(kn) == mk && this.LayerData(ln)[kn] && this.isKBKeys(kn)) {
                ret[kn] = this.LayerData(ln)[kn];
            }
        }
        return ret;
    },

    setMapping(kn, info, ln = null) {
        if (info) {
            this.LayerData(ln)[Util.normalize_combo(kn)] = info;
        } else {
            delete this.LayerData(ln)[Util.normalize_combo(kn)];
        }
    },

    // Storage Methods
    async load(name = null) {
        this.init();
        name = name || this.Name;
        if (!name) {
            return false;
        }
        let json_ = await _PROFILE_.read(name);
        if (json_ && this.loadJSON(json_)) {
            this.Name = name;
            return true;
        } else
            return false;
    },
    async save() {
        this.shrink();
        if (this._virtual) return;
        if (!this.Name) return;
        await _PROFILE_.write(this.Name, this.JSON);
    },
    async del() {
        if (this._virtual) return;
        if (!this.Name) return;
        await _PROFILE_.del(this.Name);
        this.init();
    },
    loadHelp() {
        this.loadJSON(JSON.stringify(KeymapHelp));
        this.Name = KeymapHelp["#NAME"];
        this._cur_layer = 0;
        this._virtual = true;
        this._filterkeys = [];
    },

    get KeyTable() {
        if (this._extkeys != this.Config.extkeys) {
            this._extkeys = this.Config.extkeys;
            this._keytable = Object.assign({}, KEY_TABLE_ALL);
            for (const k of this.Config.extkeys) {
                this._keytable[k] = '';
            }
        }
        return this._keytable;
    },

    // Ëá™ÂÆö‰πâ‰øÆÈ•∞ÈîÆ
    get ModKeys() {
        let mkeys = [];
        let mkeys_na = [];
        let ktable = this.getLayoutKeyTable();
        for (const mk of MODKEYS_PC.concat(MODKEYS_MAC).concat( this.Config.modkeys)) {
            if (mk in ktable) {
                mkeys.push(mk);
            } else {
                mkeys_na.push(mk);
            }
        }
        return this.Config.showall ? mkeys.concat(mkeys_na) : mkeys;
    },
    set ModKeys(v) {
        this.Config.modkeys = [];
        if (!v || v.length <= 0) {
            return;
        }
        let def_mkeys = MODKEYS_PC.concat(MODKEYS_MAC);
        for (const m of v) {
            if (!def_mkeys.includes(m)) {
                this.Config.modkeys.push(m);
            }
        }
    },

    isModKey(k) {
        return this.ModKeys.includes(k);
    },

    getModColor(k) {
        if (!this.isModKey(k)) return "";
        // let c = Object.assign({}, MODKEY_COLORS, this.Config.modkey_colors);
        let c = this.Config.modkey_colors;
        if (c[k]) {
            let cs = c[k].split("/", 2);
            if (cs.length < 2)
                return [cs[0], cs[0]]
            else
                return cs;
        } else {
            return "";
        }
    },

    getModChar(k) {
        if (!this.isModKey(k)) return "";
        // let c = Object.assign({}, MODKEY_CHARS, this.Config.modkey_chars);
        let c = this.Config.modkey_chars;
        return c[k] || k[0];
    },

    get ModKeyMode() {
        return this.Config.modkey_mode;
    },

    set ModKeyMode(v) {
        this.Config.modkey_mode = v;
    },

    get ModKeyColorMode() {
        return this.Config.modkey_clr;
    },

    set ModKeyColorMode(v) {
        this.Config.modkey_clr = Boolean(v);
    },

    getLayoutKeyTable(l = null) {
        if (l == null) l = this.Config.layout;
        let ktable = Object.assign({}, (l == "mac" ? KEY_TABLE_MAC : KEY_TABLE_PC));
        for (const xk of this.Config.extkeys) {
            ktable[xk] = "";
        }
        return ktable;
    },

    isKBKey(k) {
        return this.Config.showall ? true : (k in this.getLayoutKeyTable());
    },

    isKBKeys(combo_str) {
        if (this.Config.showall) return true;
        let ks = Util.split_combo(combo_str);
        let ktable = this.getLayoutKeyTable();
        for (const k of ks) {
            if (!(k in ktable))
                return false;
        }
        return true;
    },

    // Á≠õÈÄâ
    get FilterKeys() {
        return this._filterkeys;
    },
    isFiltered() {
        return this._filterkeys.length > 0;
    },
    addFilterKey(mk) {
        if (!this._filterkeys.includes(mk))
            this._filterkeys.push(mk);
    },
    delFilterKey(mk) {
        let i = this._filterkeys.indexOf(mk);
        if (i >= 0)
            this._filterkeys.splice(i, 1);
    },
    clearFilterKeys() {
        this._filterkeys = [];
    },
    isFilterKey(mk) {
        return this._filterkeys.includes(mk);
    },
    checkFilter(combo_str) {
        let rel = true;
        let ks = Util.split_combo(combo_str);
        for (const f of Keymap.FilterKeys) {
            if (!ks.includes(f)) {
                rel = false;
                break;
            }
        }
        return rel;
    },

    // ÈîÆÂ∏ΩÂàÜÁªÑËâ≤
    get GroupMode() {
        return this.Config.group;
    },
    set GroupMode(v) {
        this.Config.group = Boolean(v);
    },
    get GroupColors() {
        // return Object.assign({}, KEY_GROUP_COLORS, this.Config.group_colors);
        return this.Config.group_colors;
    },
    getGroupColor(g) {
        return this.GroupColors[g] || "transparent";
    },
};

var UI = {
    _launch_mode: "html",
    get LaunchMode() { return this._launch_mode; },
    set LaunchMode(v) {
        this._launch_mode = v;
        this.setFlag("launch-mode", v);
    },

    elm(sel) {
        return document.querySelector(sel);
    },

    elms(sel) {
        return document.querySelectorAll(sel);
    },

    setFlag(name, value) {
        if (value === null)
            document.documentElement.removeAttribute("data-" + name);
        else
            document.documentElement.setAttribute("data-" + name, value);
    },

    toggleFlag(name, value) {
        if (document.documentElement.getAttribute("data-" + name))
            document.documentElement.removeAttribute("data-" + name);
        else
            document.documentElement.setAttribute("data-" + name, value);
    },

    setCSS(prop, val) {
        if (!prop || !val) return false;
        for (const sheet of document.styleSheets) {
            for (const rule of sheet.cssRules) {
                if (rule.selectorText === ":root") {
                    rule.style.setProperty(prop, val);
                    return true;
                }
            }
        }
        document.styleSheets[document.styleSheets.length - 1].insertRule(`:root {${prop}: ${val}}`);
        return true;
    },

    update() {
        this.elm("#prof_name").innerText = Keymap.Name || NEW_KEYMAP;
        this.elm("#prof_name").title = Keymap.Name;
        this.elm("#pname_keymap").innerText = Keymap.Name;
        this.elm("#pname_layer").innerText = Keymap.CurLayer + (Keymap.getLayerName() ? ": "+Keymap.getLayerName() : "");
        this.Keyboard.update();
        this.List.update();
        this.Json.update();

        let elm = this.elm("#layer_btns");
        elm.innerHTML = "";
        for (let n=0; n<Keymap.Config.layers; n++) {
            let e = document.createElement("button");
            e.id = "btn_l" + n;
            e.classList.add("btn_l");
            if (n == Keymap.CurLayer)
                e.classList.add("btn_l_cur");
            e.innerHTML = Keymap.getLayerName(n) ? (`${n}:` + Keymap.getLayerName(n)) : String(n);
            e.onclick = (evt) => {
                this.changeLayer(n);
                this.update();
            };
            e.ondblclick = async (evt) => {
                await this.setLayerName(n);
                this.update();
            };
            // `<button id="btn_l${n}" class="btn">${n}</button>`
            elm.appendChild(e);
        }

        this.setFlag('layer', Keymap.CurLayer);
        let cfg = Keymap.Config;
        this.setFlag("ui", cfg.uimode);
        this.setFlag("view", cfg.view);
        this.setFlag("kbsize", Keymap.KBSize);
        this.setFlag("kbhint", cfg.kbhint);
        this.setFlag("layout", cfg.layout);
        this.setFlag("kbext", cfg.kbext);
        this.setFlag("showall", cfg.showall);
        this.setCSS("--ks1", cfg["ks1"]);
        this.setCSS("--kw1", cfg["kw1"]);
        this.setCSS("--kh1", cfg["kh1"]);
        this.setCSS("--ks2", cfg["ks2"]);
        this.setCSS("--kw2", cfg["kw2"]);
        this.setCSS("--kh2", cfg["kh2"]);
        this.setCSS("--kt2", cfg["kt2"]);
        this.setCSS("--c0", cfg["c0"]);
        this.setCSS("--c1", cfg["c1"]);
        this.setCSS("--c2", cfg["c2"]);
        this.setCSS("--c3", cfg["c3"]);
        this.setCSS("--c4", cfg["c4"]);
        this.setCSS("--cols", cfg["cols"]);
        this.resize();
    },

    resize() {
        this.setCSS("--kbw", window.getComputedStyle(this.elm("#kb_std")).width);
        this.setCSS("--w", window.getComputedStyle(this.elm("#tab_kb")).width);
    },

    async onKeyDown(evt) {
        if (evt.key == "Escape") {
            evt.target.blur();
            document.body.focus();
            return;
        }
        if (evt.target != document.body)
            return;
        let handled = true;
        let upd = true;
        switch (evt.key.toUpperCase()) {
            case "`":
                this.changeLayer(0);
                break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                this.changeLayer(parseInt(evt.key));
                break;
            case "Q":
                await this.setSize(1);
                break;
            case "W":
                await this.setSize(2);
                break;
            case "E":
                await this.setSize(3);
                break;
            case "R":
                await this.setSize(0);
                break;
            case "X":
                if (evt.shiftKey) {
                    await this.setKBExt(false);
                } else {
                    await this.setKBExt(true);
                }
                break;
            case "K":
                await this.changeView("k");
                this.setFlag("view", "k");
                upd = false;
                break;
            case "S":
                if (evt.ctrlKey) {
                    saveFile();
                    upd = false;
                }
                break;
            case "L":
                await this.changeView("l");
                this.setFlag("view", "l");
                upd = false;
                break;
            case ";":
                this.setFlag("view", "j");
                upd = false;
                break;
            case "TAB":
                evt.stopPropagation();
                evt.preventDefault();
                if (evt.shiftKey) {
                    await this.setKBHint(false);
                } else {
                    await this.setKBHint(true);
                }
                break;
            case "P":
                if (evt.ctrlKey) {
                    printAsPng(2, Keymap.getLayerPrintName());
                } else if (evt.shiftKey) {
                    await this.setUIMode("tab");
                    this.setFlag("ui", "tab");
                } else {
                    await this.setUIMode("single");
                    this.setFlag("ui", "single");
                }
                upd = false;
                break;
            case "M":
                if (evt.shiftKey) {
                    await this.setKBType("pc");
                } else {
                    await this.setKBType("mac");
                }
                break;
            case "F":
                if (evt.shiftKey) {
                    await this.setShowAll(false);
                } else {
                    await this.setShowAll(true);
                }
                break;
            case "F2":
                await this.setLayerName();
                break;
            case "O":
                if (evt.altKey) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    let pn = prompt();
                    if (pn) {
                        await this.load(pn);
                    }
                } else if (evt.ctrlKey) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    openFile().then(async (file) => { await UI.loadFile(file); });
                    upd = false;
                } else
                    handled = false;
                break;
            default:
                handled = false;
        }
        if (handled) {
            evt.stopPropagation();
            evt.preventDefault();
            if (upd)
                this.update();
        }
    },

    async onClick(evt, elm) {
        let upd = true;
        elm.blur();
        switch (elm.id) {
            case "btn_ui_tab":
                await this.setUIMode("tab");
                this.setFlag('ui', 'tab');
                upd = false;
                break;
            case "btn_ui_single":
                await this.setUIMode("single");
                this.setFlag('ui', 'single');
                upd = false;
                break;
            case "tabbtn_kb":
                await this.changeView("k");
                this.setFlag("view", "k");
                upd = false;
                break;
            case "tabbtn_list":
                await this.changeView("l");
                this.setFlag("view", "l");
                upd = false;
                break;
            case "tabbtn_json":
                this.setFlag("view", "j");
                upd = false;
                break;
            case "btn_l_clr":
                await this.clearLayer();
                break;
            case "btn_hint":
                await this.toggleKBHint();
                break;
            case "btn_layout":
                await this.toggleKBType();
                break;
            case "btn_showall":
                await this.toggleShowAll();
                break;
            case "btn_setting":
                await this.setting();
                this.Keyboard.build();
                break;
            case "btn_clr":
                await this.clear();
                break;
            case "btn_del":
                await this.delete();
                break;
            case "btn_saveas":
            case "btn_imp2":
                await this.import2();
                break;
            case "btn_imp":
                await this.import();
                break;
            case "btn_save_as_img":
                printAsPng(2, Keymap.getLayerPrintName());
                upd = false;
                break;
            case "btn_load_file":
                openFile().then(async (file) => { await UI.loadFile(file); });
                upd = false;
                break;
            case "btn_save_file":
                saveFile();
                upd = false;
                break;
            default:
                upd = false;
                console.log("Unhandled click-event. Elm: ", elm);
        }
        evt.preventDefault();
        evt.stopPropagation();
        if (upd)
            this.update();
    },

    async init() {
        Keymap.init();
        window.onkeydown = async (evt) => { await this.onKeyDown(evt); };
        window.ondragenter = (evt) => { evt.preventDefault(); };
        window.ondragover = (evt) => { evt.preventDefault(); };
        window.ondrop = async (evt) => {
            evt.preventDefault();
            await this.loadFile(evt.dataTransfer.files[0]);
        };
        this.elm("#prof_name").onclick = async (evt) => { await this.showProfileList(); }
        this.elm("#comment").onchange = async (evt) => { Keymap.setMapping("#comment", this.elm("#comment").value); await this.save(); this.update(); }

        this.Keyboard.init();

        // await this.loadFirstProf();
        await this.loadLastProf();
        this.update();

        for (const elm of this.elms(".BIND-CLICK")) {
            elm.onclick = async (evt) => { await this.onClick(evt, elm); };
        }
    },

    async loadFirstProf() {
        let l = await _PROFILE_.all();
        if (l.length > 0) {
            l.sort((a, b) => a.localeCompare(b, "zh"));
            if (await Keymap.load(l[0])) {
                _PROFILE_.setLast(Keymap.Name);
            } else {
                Keymap.loadHelp();
            }
        } else {
            // Keymap.init();
            Keymap.loadHelp();
        }
        this.Keyboard.build();
    },

    async loadLastProf() {
        let last = await _PROFILE_.getLast();
        if (last && await Keymap.load(last)) {
            this.Keyboard.build();
        } else {
            this.loadFirstProf();
        }
    },

    async showProfileList() {
        function hideList() {
            for (const e of document.querySelectorAll(".prof_list")) {
                e.remove();
            }
        }
        function genProf(prof, add_cls, onclick) {
            let elm = document.createElement("DIV");
            elm.classList.add("prof_name");
            if (add_cls) elm.classList.add(...add_cls);
            if (onclick) elm.onclick = onclick;
            elm.innerHTML = prof;
            elm.title = prof;
            return elm;
        }

        hideList();

        let s = [];
        let l = await _PROFILE_.all();
        if (l.length > 0) {
            l.sort((a, b) => a.localeCompare(b, "zh"));
            for (const p of l) {
                s.push(genProf(p, null, async () => {hideList(); await this.load(p); this.update();}));
            }
        }
        let elm_new = genProf(NEW_KEYMAP, ["prof_cmd"], async () => {hideList(); await this.new(); this.update();});
        s.push(elm_new);
        s.push(genProf(KeymapHelp["#NAME"], ["prof_cmd"], async () => {hideList(); Keymap.loadHelp(); this.Keyboard.build(); this.update();}));
        let temp = document.createElement("span");
        temp.innerHTML = `<div class="prof_list" style="position:absolute;box-shadow: 0px 3px 6px #000;opacity: 0;"></div>`;
        let elm_list = temp.children[0];
        elm_list.append(...s);
        elm_list.onmouseleave = hideList;
        let elm_prof = this.elm("#prof_name");
        document.body.appendChild(elm_list);
        elm_list.style.left = elm_prof.offsetLeft - 5;
        elm_list.style.top = elm_prof.offsetTop - 5; // - elm_new.offsetHeight - 5;
        elm_list.style.opacity = 1;
    },

    // Data Operation Methods
    async new() {
        let name = await get_name_dlg("ËØ∑ËæìÂÖ•ÈîÆË∞±ÂêçÔºö");
        if (name) {
            Keymap.init(name);
            await Keymap.save();
            await _PROFILE_.setLast(Keymap.Name);
        }
    },

    async save(force = true) {
        if (!Keymap.Name) {
            // if (!force) return;
            Keymap.Name = await get_name_dlg("ËØ∑ËæìÂÖ•ÈîÆË∞±ÂêçÔºö");
        }
        if (!Keymap.Name) return;
        await Keymap.save();
    },

    async load(name) {
        if (!await Keymap.load(name)) {
            alert(`Êó†Ê≥ïËΩΩÂÖ•ÈîÆË∞±„Ää${name}„Äã`);
            // await this.loadFirstProf();
            await this.loadLastProf();
            return;
        }
        await _PROFILE_.setLast(Keymap.Name);
        this.Keyboard.build();
    },

    async delete() {
        if (!confirm(`Á°ÆËÆ§Ë¶ÅÂà†Èô§ÈîÆË∞±„Ää${Keymap.Name}„ÄãÔºü`)) return;
        await Keymap.del();
        await this.loadFirstProf();
    },

    async import() {
        let json_ = this.Json.Value;
        if (!json_)
            return;
        if (Keymap.loadJSON(json_)) {
            await this.save();
        }
    },

    async import2() {
        let json_ = this.Json.Value;
        if (!json_)
            return;
        let name = await get_name_dlg("ËØ∑ËæìÂÖ•ÈîÆË∞±ÂêçÔºö");
        if (name) {
            Keymap.init();
            if (!Keymap.loadJSON(json_))
                return;
            Keymap.Name = name;
            await this.save();
            await _PROFILE_.setLast(Keymap.Name);
        }
    },

    async clear() {
        if (!confirm(`Á°ÆËÆ§Ë¶ÅÊ∏ÖÁ©∫Êï¥‰∏™ÈîÆË∞±„Ää${Keymap.Name}„ÄãÔºü`)) return;
        Keymap.clear();
        await this.save(false);
    },

    //Rename layer
    async setLayerName(ln = null) {
        ln = ln || Keymap.CurLayer;
        let name = await get_name_dlg(`ËØ∑ËæìÂÖ•ÈîÆÁõòÂ±Ç„Äê ${ln} „ÄëÂêçÂ≠óÔºö`, Keymap.getLayerName(ln), false, true);
        if (name != null) {
            Keymap.setLayerName(name, ln);
            await this.save(false);
        }
    },

    async clearLayer() {
        if (!confirm(`Á°ÆËÆ§Ë¶ÅÊ∏ÖÁ©∫ÈîÆÁõòÂ±Ç„Äê ${Keymap.CurLayer} „ÄëÔºü`)) return;
        Keymap.clearLayer();
        await this.save(false);
    },

    // UI Operation Methods

    async setUIMode(v) {
        Keymap.Config.uimode = v;
        await this.save(false);
    },

    async changeView(view) {
        if (view == "k" || view == "l") {
            Keymap.Config.view = view;
            await this.save(false);
        }
    },

    changeLayer(ln) {
        if (ln < 0 || ln > Keymap.Config.layers) return;
        Keymap.CurLayer = ln;
    },

    async changeSize(delta) {
        Keymap.KBSize += delta;
        await this.save(false);
    },

    async setSize(s) {
        Keymap.KBSize = s;
        await this.save(false);
    },

    async setKBExt(v) {
        Keymap.Config.kbext = Boolean(v);
        await this.save(false);
    },
    async toggleKBExt() {
        await this.setKBExt(!Keymap.Config.kbext);
    },

    async setKBHint(v) {
        Keymap.Config.kbhint = Boolean(v);
        await this.save(false);
    },
    async toggleKBHint() {
        await this.setKBHint(!Keymap.Config.kbhint);
    },

    async setKBType(v) {
        Keymap.Config.layout = v;
        await this.save(false);
    },
    async toggleKBType() {
        await this.setKBType((Keymap.Config.layout == "mac") ? "pc" : "mac");
    },

    async setShowAll(v) {
        Keymap.Config.showall = Boolean(v);
        await this.save(false);
    },
    async toggleShowAll() {
        await this.setShowAll(!Keymap.Config.showall);
    },
    async setting() {
        await setting_dlg();
        await this.save();
    },

    toggleMapping(mk, multi) {
        // this.List.toggleMapping(this.Keyboard.toggleMapping(mk));
        if (Keymap.isFilterKey(mk)) {
            if (multi)
                Keymap.delFilterKey(mk);
            else
                Keymap.clearFilterKeys();
        } else {
            if (!multi)
                Keymap.clearFilterKeys();
            Keymap.addFilterKey(mk);
        }
        this.Keyboard.update();
        this.List.update();
    },

    // Keymapping Methods
    async setMapping(kn) {
        let s = await setmapping_dlg(kn);
        if (s != null) {
            if (s.length > 0) {
                Keymap.setMapping(...s);
            } else {
                for (const k in Keymap.getAllMappings(Util.get_mainkey(kn))) {
                    Keymap.setMapping(k, "");
                }
            }
            await this.save();
            this.update();
        }
    },

    // File operation
    async loadFile(file) {
        if (file.name.toLowerCase().endsWith(".keymap")) {
            let name = file.name.slice(0, -7); //
            if (confirm(`ÊòØÂê¶ËΩΩÂÖ•ÈîÆË∞±„Ää${name}„ÄãÔºü\n\n„Äê*„ÄëÂ¶ÇÊûúÂ≠òÂú®ÂêåÂêçÈîÆË∞±Â∞ÜË¢´Ë¶ÜÁõñ`)) {
                let json_ = await file.text();
                Keymap.init();
                if (!Keymap.loadJSON(json_))
                    return;
                Keymap.Name = name;
                await this.save();
                await _PROFILE_.setLast(Keymap.Name);
                this.update();
            }
        } else {
            alert("‰ªÖÊîØÊåÅ '.keymap' Êñá‰ª∂");
        }
    },
}

UI.Keyboard = {
    _inited: false,
    Elm: UI.elm("#kb_std"),
    ElmExt: UI.elm("#kb_ext"),

    get Ks() {
        return UI.elms("k");
    },

    K(mk) {
        return UI.elm(`k[data-k="${mk}"]`);
    },

    showTip(elm_k) {
        if (!elm_k.classList.contains("set")) return;
        this.clearTips();
        let s = [];
        let l = Keymap.getAllMappings(elm_k.dataset.k);
        for (const kn in l) {
            s.push(`${Util.gen_combo_kn_elm(kn)}<km>${l[kn]}</km>`);
        }
        if (s.length <= 0) return;
        let temp = document.createElement("span");
        temp.innerHTML = `<div class="kms_info">${s.join("")}</div>`;
        let elm_tip = temp.children[0];
        let ktable = Keymap.getLayoutKeyTable();
        for (const kn of elm_tip.querySelectorAll("kn")) {
            if (!(kn.innerText in ktable)) {
                kn.classList.add("na");
            }
        }
        elm_tip.style.minWidth = "var(--kw)";
        elm_tip.style.minHeight = "var(--kh)";
        let elm_parent = (this.Elm.contains(elm_k)) ? this.Elm : this.ElmExt;
        elm_parent.appendChild(elm_tip);
        if (elm_k.offsetLeft > elm_parent.offsetWidth - elm_tip.offsetWidth)
            elm_tip.style.left = elm_k.offsetLeft + elm_k.offsetWidth - elm_tip.offsetWidth;
        else
            elm_tip.style.left = elm_k.offsetLeft;
        if (elm_k.offsetTop > elm_parent.offsetHeight - elm_tip.offsetHeight - 2) {
            elm_tip.style.top = elm_parent.offsetHeight - elm_tip.offsetHeight - 4;
        } else {
            elm_tip.style.top = elm_k.offsetTop;
        }
        if (elm_tip.offsetTop < 2) {
            elm_tip.style.top = 0;
            elm_tip.style.maxHeight = elm_parent.offsetHeight - 4;
        }
        if (elm_tip.offsetLeft < 2) {
            elm_tip.style.left = 2;
            elm_tip.style.maxWidth = elm_parent.offsetWidth - 4;
        }
        elm_tip.style.opacity = 1;
    },

    clearTips() {
        for (const e of document.querySelectorAll(".kms_info")) {
            e.remove();
        }
    },

    _genElmK(kn) {
        return `<div class="ktn">${kn}</div><div class="ktr"><div class="modkeys"></div><div class="mk">${kn}</div><div class="cnt"></div></div><div class="ktm"></div>`;
    },

    init() {
        if (this._inited) return;
        this._inited = true;
        for (const elm of this.Ks) {
            elm.dataset.k = elm.innerHTML;
        }
        this.build();
    },

    build() {
        // add extkeys
        let s = [];
        for (const k of Keymap.Config.extkeys) {
            if (k == "__CR/LF__") {
                // s.push(`<span style="width:100%;margin:-10px;"></span>`);
                s.push("</krx><krx>")
            } else if (k[0] == "#") {
                s.push(`<d class="d1 f-end">${k.substring(1)}</d>`);
            } else {
                let e = document.createElement("k");
                e.dataset.k = k;
                e.innerHTML = this._genElmK(k);
                s.push(e.outerHTML);
                // s.push(`<k data-k="${k}">${this._genElmK(k)}</k>`);
            }
        }
        if (s.length > 0)
            this.ElmExt.innerHTML = "<krx>" + s.join("") + "</krx>";
        else
            this.ElmExt.innerHTML = "";
        for (const elm of this.Ks) {
            if (elm.dataset.k in Keymap.KeyTable) {
                elm.classList.remove("dis");
                elm.innerHTML = this._genElmK(Keymap.KeyTable[elm.dataset.k] || elm.dataset.k);
                elm.onmouseenter = (evt) => { this.showTip(elm) };
                elm.onmouseleave = (evt) => { this.clearTips() };
                // elm.onclick = (evt) => { UI.setMapping(elm.dataset.k); };
                elm.onclick = (evt) => { UI.setMapping(elm.querySelector(".ktr").dataset.k || elm.dataset.k); };
                elm.oncontextmenu = (evt) => {
                    evt.preventDefault();
                    UI.toggleMapping(elm.dataset.k, evt.ctrlKey);
                }
            } else {
                elm.classList.add("dis");
            }
        }
    },

    updateK(elm_k) {
        let mk = elm_k.dataset.k;
        if (!mk || !(mk in Keymap.KeyTable)) {
            console.log(mk);
            return;
        }
        // Ê∏ÖÁêÜ css class
        elm_k.classList.remove("mod", "set", "sel", "rel", "no-rel", "group");
        let elm_ktr = elm_k.querySelector(".ktr");
        elm_ktr.dataset.k = "";
        let elm_mk = elm_ktr.querySelector(".mk");
        elm_mk.innerHTML = Keymap.KeyTable[mk] || mk;
        let elm_modkeys = elm_ktr.querySelector(".modkeys");
        elm_modkeys.innerHTML = "";
        let elm_cnt = elm_ktr.querySelector(".cnt");
        elm_cnt.innerHTML = "";
        let elm_ktm = elm_k.querySelector(".ktm");
        elm_ktm.innerHTML = "";
        elm_ktm.classList.remove("na");
        let ks = Keymap.getAllMappings(mk);
        let ktable = Keymap.getLayoutKeyTable();
        if (!Util.is_empty_obj(ks)) {
            elm_k.classList.add("set");
            let cnt = Object.keys(ks).length;
            for (const k in ks) {
                elm_ktm.classList.remove("na");
                let ktm = ks[k];
                let na = false;
                if (ktm.startsWith("* ")) {
                    cnt = Object.keys(ks).length - 1;
                    elm_ktr.dataset.k = k;
                    let l = Util.split_combo(k);
                    l.pop();
                    let s = "";
                    for (const m of l) {
                        let txt = "";
                        if (Keymap.ModKeyMode == "raw")
                            txt = m;
                        else if (Keymap.ModKeyMode == "chr")
                            txt = Keymap.getModChar(m) || m[0];
                        let clr = Keymap.getModColor(m) || ["transparent", "transparent"];
                        s += `<div class="mod ${Keymap.ModKeyColorMode?'mod_color':''} mod_${Keymap.ModKeyMode} ${m in ktable?'':'na'}" data-k="${m}" style="${clr[0]?'--mod-c1:'+clr[0]+';':''}${clr[1]?'--mod-c2:'+clr[1]+';':''}">${txt}</div>`;
                        if (!(m in ktable)) {
                            elm_ktm.classList.add("na");
                            na = true;
                        }
                    }
                    elm_modkeys.innerHTML = s;
                    let mps = ktm.trim().split('\n');
                    elm_ktm.innerHTML = mps[0].substr(2);
                    // keycap group color
                    if (Keymap.GroupMode && !na) {
                        elm_k.classList.add("group");
                        let g = mps.pop();
                        if (g.startsWith("::")) {
                            elm_k.style.setProperty("--gc", Keymap.getGroupColor(g.substr(2)));
                        } else {
                            elm_k.style.removeProperty("--gc");
                        }
                    }
                }
            }
            elm_cnt.innerText = cnt ? "+"+cnt : "";
        }
        // set modkey style
        if (Keymap.isModKey(mk)) {
            elm_k.classList.add("mod");
            if (Keymap.ModKeyColorMode) {
                let clr = Keymap.getModColor(mk);
                if (clr) {
                    elm_mk.classList.add("mod_color")
                    elm_mk.style.setProperty("--mod-c1", clr[0]);
                    elm_mk.style.setProperty("--mod-c2", clr[1]);
                }
            }
        }
        // check filter keys
        if (Keymap.isFiltered()) {
            if (Keymap.isFilterKey(mk)) {
                elm_k.classList.add("sel");
            } else if (Util.is_empty_obj(ks)) {
                elm_k.classList.add("no-rel");
            } else {
                let rel = false;
                for (const kn in ks) {
                    if (Keymap.checkFilter(kn)) {
                        rel = true;
                        break;
                    }
                }
                if (rel) {
                    elm_k.classList.add("rel");
                } else {
                    elm_k.classList.add("no-rel");
                }
            }
        }
    },

    update() {
        for (const elm_k of this.Ks) {
            this.updateK(elm_k);
        }
        UI.elm("#comment").value = Keymap.getMapping("#comment");
    },
};

UI.List = {
    Elm: UI.elm("#list"),

    get Items() {
        return this.Elm.querySelectorAll(".kinfo");
    },

    update() {
        let s = [];
        for (const mk in Keymap.KeyTable) {
            let l = Keymap.getAllMappings(mk);
            if (Util.is_empty_obj(l)) continue;
            for (const kn in l) {
                s.push(`${Util.gen_combo_kn_elm(kn)}<km data-mainkey="${mk}" data-combo="${kn}" class="kinfo">${l[kn]}</km>`);
            }
            // s.push(`<div style="grid-column: 1 / -1;height:0px;"></div>`);
        }
        this.Elm.innerHTML = s.join('\n');
        let ktable = Keymap.getLayoutKeyTable();
        for (const kn of this.Elm.querySelectorAll("kn")) {
            if (!(kn.innerText in ktable)) {
                kn.classList.add("na");
            }
        }
        for (const i of this.Items) {
            i.ondblclick = async (evt) => { await UI.setMapping(i.dataset.combo); };
        }
        // check filter keys
        if (Keymap.isFiltered()) {
            for (const i of this.Items) {
                if (Keymap.checkFilter(i.dataset.combo)) {
                    for (const ck of i.querySelectorAll("kn")) {
                        if (Keymap.isFilterKey(ck.dataset.k)) {
                            ck.classList.add("sel");
                        }
                    }
                } else
                    i.classList.add("no-rel");
            }
        }
    },
};

UI.Json = {
    Elm: UI.elm("#json"),

    get Value() {
        return this.Elm.value;
    },

    update() {
        this.Elm.value = Keymap.JSON;
    },
};

async function get_name_dlg(info, def_val = "", check_filename=true, allow_empty = false) {
    return new Promise((resolver) => {
        let html = `<dialog class="name_dlg">
            <div style="font-weight: bold">${info || "ËØ∑ËæìÂÖ•Ôºö"}</div>
            <div><input type="text" id="name" size="50" autofocus /></div>
            <div style="text-align: right;">
                <button class="btn btnok">Á°ÆÂÆö</button>
                <button class="btn btncancel">ÂèñÊ∂à</button>
            </div>
            </dialog>`;
        let tmp = document.createElement("div");
        tmp.innerHTML = html;
        let dlg = tmp.children[0];
        let elm_name = dlg.querySelector("#name");
        if (def_val) {
            elm_name.value = def_val;
        }
        function _ok() {
            let name = elm_name.value;
            if (!name && !allow_empty) {
                alert("‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
                elm_name.focus();
                return;
            }
            if (check_filename && name.search(/[\*\?\\\/\:\"\<\>\|]/) >= 0) {
                alert(`ÂêçÂ≠ó‰∏≠‰∏çËÉΩÂåÖÂê´ \* \? \\ \/ \: \" \< \> \|`);
                elm_name.focus();
                return;
            }
            dlg.remove();
            resolver(name.trim());
        }
        function _cancel() {
            dlg.remove();
            resolver();
        }
        dlg.querySelector(".btnok").onclick = _ok;
        elm_name.onkeydown = (evt) => {
            if (evt.key == "Enter") {
                evt.preventDefault();
                evt.stopPropagation();
                _ok();
                return;
            }
        }
        dlg.querySelector(".btncancel").onclick = _cancel;
        dlg.onclose = _cancel;
        document.body.appendChild(dlg);
        dlg.showModal();
    });
};

async function setmapping_dlg(combo_str) {
    return new Promise((resolver) => {
        let cks = Util.split_combo(combo_str);
        let mk = cks.pop();
        let s = [];
        for (const k of Keymap.ModKeys) {
            if (k != mk && Keymap.isKBKeys(k)) {
                let clr = Keymap.getModColor(k) || ["transparent", "transparent"];
                s.push(`<label><input type="checkbox" value="${k}" /><kn class="ck ${Keymap.ModKeyColorMode?'mod_color':''} mod_${Keymap.ModKeyMode}" style="${clr[0]?'--mod-c1:'+clr[0]+';':''}${clr[1]?'--mod-c2:'+clr[1]+';':''}">${k}</kn></label>`)
            }
        }
        let html = `<dialog class="kmdlg">
            <div style="display: flex;gap: 5px;">
                <div style="display:grid;grid-auto-flow:column;grid-template-rows:repeat(6, max-content);gap: 10px;width:fit-content;">
                    ${s.join("")}
                </div>
                <kn>${mk}</kn>
                <textarea id="mapping" style="flex: 1;border-width:1px;" autofocus>${Keymap.getMapping(combo_str) || ""}</textarea>
            </div>
            <div>
            Êò†Â∞Ñ‰ø°ÊÅØ‰ª•"* "ÔºàÊòüÂè∑+Á©∫Ê†ºÔºâÂºÄÂ§¥ÁöÑÁªÑÂêàÈîÆÂÆö‰πâ‰∏∫‰∏ªÊò†Â∞ÑÔºåÂú®‚ÄúÈîÆÂ∏ΩÊèêÁ§∫‚ÄùÊ®°Âºè‰∏ã‰ºöÂú®ÈîÆÂ∏Ω‰∏äÊòæÁ§∫Á¨¨‰∏ÄË°åÊñáÂ≠óÔºåÂπ∂‰∏î‰∏ªÊò†Â∞ÑÁöÑÁªÑÂêàÈîÆ‰ºöÁõ¥Êé•ÊòæÁ§∫Âú®ÈîÆÂ∏Ω‰∏ä„ÄÇ
            </div>
            <div style="text-align: right;">
                <button class="btn btnclr danger" style="float:left;">Ê∏ÖÁ©∫Êú¨ÈîÆÊâÄÊúâÊò†Â∞Ñ‰ø°ÊÅØ</button>
                <button class="btn btnok">Á°ÆÂÆö</button>
                <button class="btn btncancel">ÂèñÊ∂à</button>
            </div>
        </dialog>`;
        let tmp = document.createElement("div");
        tmp.innerHTML = html;
        let dlg = tmp.children[0];
        let ktable = Keymap.getLayoutKeyTable();
        for (const kn of dlg.querySelectorAll("kn")) {
            if (!(kn.innerText in ktable)) {
                kn.classList.add("na");
            }
        }
        dlg.querySelectorAll('input[type="checkbox"]').forEach(elm => {
            if (cks.includes(elm.value)) elm.checked = true;
            elm.onclick = (evt) => {
                let kn = [];
                for (const elm of dlg.querySelectorAll('input[type="checkbox"]:checked')) {
                    kn.push(elm.value);
                }
                kn.sort();
                kn.push(mk);
                let inf = Keymap.getMapping(kn.join("+"));
                let m = dlg.querySelector("#mapping");
                m.value = (inf || "").trim();
                m.focus();
            }
        });
        dlg.querySelector(".btnok").onclick = (evt) => {
            let kn = [];
            for (const elm of dlg.querySelectorAll('input[type="checkbox"]:checked')) {
                kn.push(elm.value);
            }
            kn.sort();
            kn.push(mk);
            let inf = dlg.querySelector("#mapping").value;
            dlg.remove();
            resolver([kn.join("+"), inf.trim()]);
        };
        dlg.querySelector(".btnclr").onclick = (evt) => {
            if (!confirm(`Á°ÆËÆ§Ë¶ÅÊ∏ÖÁ©∫ÈîÆ„Äê ${mk} „ÄëÊâÄÊúâÊò†Â∞Ñ‰ø°ÊÅØÔºü`)) return;
            dlg.remove();
            resolver([]);
        };
        dlg.querySelector(".btncancel").onclick = (evt) => {
            dlg.remove();
            resolver();
        };
        dlg.onclose = (evt) => {
            dlg.remove();
            resolver();
        }
        document.body.appendChild(dlg);
        dlg.showModal();
    });
}

async function setting_dlg() {
    return new Promise((resolver) => {
        let cfg = Keymap.Config;
        let html = `<dialog class="stdlg">
            <div class="sts">
                <div class="subttl">ÈîÆÂ∏ΩÈÖçËâ≤</div>
                <span>ÈªòËÆ§Â≠óÁ¨¶</span><input type="text" id="c3" style="width: 6rem;" />
                <span>ÈªòËÆ§ÈîÆÂ∏ΩËâ≤</span><input type="text" id="c4" style="width: 6rem;grid-column: 4 / -1;" />
                <span>È´ò‰∫ÆÂ≠óÁ¨¶</span><input type="text" id="c0" style="width: 6rem;" />
                <span>È´ò‰∫ÆÈîÆÂ∏ΩËâ≤</span><input type="text" id="c1" style="width: 6rem;" />
                <span>È´ò‰∫ÆËæπÊ°Ü</span><input type="text" id="c2" style="width: 6rem;" />
                <div class="subttl">ÈîÆÂ∏ΩÊ†áÂáÜÊ®°Âºè</div>
                <span>ÈîÆÂÆΩ</span><input type="number" id="kw1" min="0.1" max="10" step="0.1" style="width: 3rem;" />
                <span>ÈîÆÈ´ò</span><input type="number" id="kh1" min="0.1" max="10" step="0.1" style="width: 3rem;" />
                <span>Â≠óÊØçÂ§ßÂ∞è</span><input type="number" id="ks1" min="0.1" max="10" step="0.05" style="width: 3rem;" />
                <div class="subttl">ÈîÆÂ∏ΩÊèêÁ§∫Ê®°Âºè</div>
                <span>ÈîÆÂÆΩ</span><input type="number" id="kw2" min="0.1" max="10" step="0.1" style="width: 3rem;" />
                <span>ÈîÆÈ´ò</span><input type="number" id="kh2" min="0.1" max="10" step="0.1" style="width: 3rem;" />
                <span>Â≠óÊØçÂ§ßÂ∞è</span><input type="number" id="ks2" min="0.1" max="10" step="0.05" style="width: 3rem;" />
                <span>ÊèêÁ§∫Â§ßÂ∞è</span><input type="number" id="kt2" min="0.1" max="10" step="0.05" style="width: 3rem;" />
                <div class="subttl">ÈîÆË∞±ËÆæÁΩÆ</div>
                <span>‰∏ªÈîÆÁõòÂ§ßÂ∞è</span>
                <select id="kbsize" style="width: 4rem;">
                    <option value="0">ÈöêËóè</option>
                    <option value="1">60%</option>
                    <option value="2">80%</option>
                    <option value="3">Ê†áÂáÜ</option>
                </select>
                <span>Êâ©Â±ïÈîÆÂå∫</span><label><input type="checkbox" id="kbext" />ÊòæÁ§∫</label>
                <span>ÈîÆÁõòÂ±ÇÊï∞</span><input type="number" id="layers" min="1" step="1" style="width: 3rem;" />
                <span>ÈîÆË°®ÂàóÊï∞</span><input type="number" id="cols" min="1" max="10" step="1" style="width: 3rem;" />
                <span>Ëá™ÂÆö‰πâÊâ©Â±ïÈîÆ</span><textarea id="extkeys" style="height: 5rem;border:1px solid black;white-space: nowrap;grid-column: 2 / -1;"></textarea>
                <span><label><input type="checkbox" id="group" />ÂàÜÁªÑÈ¢úËâ≤</label></span><textarea id="group_colors" style="grid-column: 2 / -1;height: 3rem;border:1px solid black;"></textarea>
                <div class="subttl">‰øÆÈ•∞ÈîÆ</div>
                <span>Ëá™ÂÆö‰πâÈîÆ</span><input type="text" id="modkeys" style="grid-column: 2 / -1;" />
                <span>ÈîÆÂ∏ΩÊòæÁ§∫</span>
                <select id="modkey_mode" style="width: 4rem;grid-column: 2 / -1;">
                    <option value="raw">ÈîÆÂêç</option>
                    <option value="chr">Áº©ÂÜô</option>
                    <option value="dot">‰ªÖÈ¢úËâ≤</option>
                </select>
                <span>Áº©ÂÜô</span><textarea id="modkey_chars" style="height: 4rem;border:1px solid black;grid-column: 2 / -1;"></textarea>
                <span><label><input type="checkbox" id="modkey_clr" />ÂêØÁî®È¢úËâ≤</label></span><textarea id="modkey_colors" style="height: 6rem;border:1px solid black;grid-column: 2 / -1;"></textarea>
            </div>
            <div style="text-align: right;">
                <button class="btn btnclr danger" style="float:left;">Reset</button>
                <button class="btn btnok">Á°ÆÂÆö</button>
                <button class="btn btncancel">ÂèñÊ∂à</button>
            </div>
            </dialog>`;
        let tmp = document.createElement("div");
        tmp.innerHTML = html;
        let dlg = tmp.children[0];
        for (const c of dlg.querySelectorAll("input,textarea,select")) {
            switch (c.id) {
                case "kbsize":
                    c.value = Keymap.KBSize;
                    break;
                case "extkeys":
                    c.value = cfg.extkeys.join(",").replaceAll("__CR/LF__,", "\n").replaceAll("__CR/LF__", "\n");
                    break;
                case "modkeys":
                    c.value = cfg.modkeys.join(", ");
                    break;
                case "kbext":
                    c.checked = cfg.kbext;
                    break;
                case "modkey_colors": {
                    let l = [];
                    for (const mk in cfg.modkey_colors) {
                        if (cfg.modkey_colors[mk])
                            l.push(mk+"::"+cfg.modkey_colors[mk]);
                    }
                    c.value = l.join(", ");
                    break;
                }
                case "modkey_chars": {
                    let l = [];
                    for (const mk in cfg.modkey_chars) {
                        if (cfg.modkey_chars[mk])
                            l.push(mk+"::"+cfg.modkey_chars[mk]);
                    }
                    c.value = l.join(", ");
                    break;
                }
                case "modkey_clr":
                    c.checked = cfg.modkey_clr;
                    break;
                case "group":
                    c.checked = cfg.group;
                    break;
                case "group_colors": {
                    let l = [];
                    for (const gn in cfg.group_colors) {
                        if (cfg.group_colors[gn])
                            l.push(gn+"::"+cfg.group_colors[gn]);
                    }
                    c.value = l.join(", ");
                    break;
                }
                default:
                    c.value = cfg[c.id];
            }
        }
        dlg.querySelector(".btnok").onclick = (evt) => {
            for (const c of dlg.querySelectorAll("input,textarea,select")) {
                switch (c.id) {
                    case "extkeys":
                        cfg.extkeys = [];
                        for (const l of c.value.trim().split("\n")) {
                            if (l.trim()) {
                                let n = 0;
                                for (const xk of l.split(/\s*,\s*/)) {
                                    if (xk) {
                                        cfg.extkeys.push(xk);
                                        n ++;
                                    }
                                }
                                if (n) {
                                    cfg.extkeys.push("__CR/LF__");
                                }
                            }
                        }
                        while (cfg.extkeys[cfg.extkeys.length - 1] == "__CR/LF__") {
                            cfg.extkeys.pop();
                        }
                        break;
                    case "kbsize":
                        Keymap.KBSize = parseInt(c.value);
                        break;
                    case "modkeys":
                        if (c.value.trim())
                            Keymap.ModKeys = c.value.trim().split(/\s*,\s*/);
                        else
                            Keymap.ModKeys = null;
                        break;
                    case "kbext":
                        cfg.kbext = c.checked;
                        break;
                    case "modkey_colors":
                        cfg.modkey_colors = {};
                        for (const m of c.value.trim().split(/\s*,\s*/)) {
                            let mm = m.split("::", 2);
                            if (mm[1]) {
                                cfg.modkey_colors[mm[0]] = mm[1];
                            }
                        }
                        break;
                    case "modkey_chars":
                        cfg.modkey_chars = {};
                        for (const m of c.value.trim().split(/\s*,\s*/)) {
                            let mm = m.split("::", 2);
                            if (mm[1]) {
                                cfg.modkey_chars[mm[0]] = mm[1];
                            }
                        }
                        break;
                    case "modkey_mode":
                        cfg.modkey_mode = c.value;
                        break;
                    case "modkey_clr":
                        cfg.modkey_clr = c.checked;
                        break;
                    case "group":
                        cfg.group = c.checked;
                        break;
                    case "group_colors":
                        cfg.group_colors = {};
                        for (const g of c.value.trim().split(/\s*,\s*/)) {
                            let gg = g.split("::", 2);
                            if (gg[1]) {
                                cfg.group_colors[gg[0]] = gg[1];
                            }
                        }
                        break;
                    default:
                        cfg[c.id] = c.value;
                }
            }
            dlg.remove();
            resolver(true);
        };
        dlg.querySelector(".btnclr").onclick = (evt) => {
            if (!confirm(`Á°ÆËÆ§Ë¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËÆæÁΩÆÔºü`)) return;
            Keymap.resetConfig();
            dlg.remove();
            resolver(true);
        };
        dlg.querySelector(".btncancel").onclick = (evt) => {
            dlg.remove();
            resolver();
        };
        dlg.onclose = (evt) => {
            dlg.remove();
            resolver();
        }
        document.body.appendChild(dlg);
        dlg.showModal();
    })
};

// Convert to img
function printAsPng(imgScale, imgName) {
    // change uimode to 'single'
    UI.setFlag('ui', 'single');
    //hide button
    document.getElementById("btn_save_as_img").style.visibility = "hidden";
    html2canvas(document.body, {
        backgroundColor: null,
        scale: imgScale,
        windowWidth: document.body.style.width,
        windowHeight: document.body.style.height,
        removeContainer: true
    }).then(canvas => {
        if (UI.LaunchMode == "exe") {
            let h=canvas.height/2, w=canvas.width/2, s=1;
            if (h > (window.innerHeight-100) || w > (window.innerWidth-100)) {
                s = Math.min((window.innerHeight-100)/h, (window.innerWidth-100)/w);
            }
            canvas.style.height=h*s;
            canvas.style.width=w*s;
            let dlg=document.createElement("dialog");
            dlg.style.marginTop="auto";
            dlg.style.marginLeft="auto";
            dlg.style.transform="unset";
            dlg.innerHTML=`<div style="position:absolute;top:0px;right:0px;margin:10px;font-size:1.5rem;background-color:var(--ui-bgc);border-width:2px;outline:3px solid white;" class="btn rnd close">&times;</div>
            <div style="pointer-events:none;position:absolute;top:50px;left:0px;margin:12px;font-size:1.5rem;padding:10px;color:red;background-color:rgba(255,255,255,0.6);border:2px dashed red;border-radius:10px;box-shadow:0px 0px 10px;">Âè≥ÈîÆÁÇπÂáªÔºåÈÄâÊã©‚ÄúÂ∞ÜÈìæÊé•Âè¶Â≠ò‰∏∫/Save link as‚Äù</div>
            <div><a href="${canvas.toDataURL()}" download="${imgName}" style="cursor:default;"></a></div>`;
            let a = dlg.querySelector("a");
            a.onclick=(evt) => {evt.preventDefault();evt.stopImmediatePropagation()};
            a.oncontextmenu=(evt) => {evt.stopImmediatePropagation();};
            a.appendChild(canvas);
            dlg.querySelector(".close").onclick = () => {dlg.remove();};
            dlg.onclose = () => {dlg.remove();};
            document.body.appendChild(dlg);
            dlg.showModal();
        } else {
            canvas.toBlob(blob => { saveAs(blob, imgName); });
        }
    });
    //show button
    document.getElementById("btn_save_as_img").style.visibility = "visible";
    // recover uimode
    UI.setFlag('ui', Keymap.Config.uimode);
}
// open file
async function openFile() {
    return new Promise((resolver) => {
        let fileSelector = document.createElement("input");
        fileSelector.setAttribute("type", "file");
        fileSelector.setAttribute("accept", ".keymap");
        fileSelector.click();
        // get the selected filepath
        fileSelector.onchange = async function() {
            resolver(this.files[0]);
        };
        fileSelector.remove();
    });
}
// save file
function saveFile() {
    let blob = new Blob([Keymap.JSON], { type: "application/json;charset=utf-8" });
    if (UI.LaunchMode == "exe") {
        let dlg=document.createElement("dialog");
        dlg.onclose=()=>{dlg.remove();};
        // dlg.style.marginTop="auto";
        // dlg.style.marginLeft="auto";
        // dlg.style.transform="unset";
        let fname=Keymap.Name.replace(/[\*\?\\\/\:\"\<\>\|]/, "_") + ".keymap";
        dlg.innerHTML=`<div style="position:absolute;top:0px;right:0px;margin:10px;font-size:1rem;outline:2px solid white;" class="btn rnd close">&times;</div>
        <div style="font-weight:bold;">‰øùÂ≠òÊñá‰ª∂</div>
            <div style="padding:10px;">
            <a href="${window.URL.createObjectURL(blob)}" download="${fname}" class="btn rnd">${fname}</a> &lt;- Âè≥ÈîÆÁÇπÂáªÔºåÈÄâÊã©‚ÄúÂ∞ÜÈìæÊé•Âè¶Â≠ò‰∏∫/Save link as‚Äù
            </div>`;
        let a = dlg.querySelector("a");
        a.onclick=(evt) => {evt.preventDefault();evt.stopImmediatePropagation();};
        a.oncontextmenu=(evt) => {evt.stopImmediatePropagation();};
        dlg.querySelector(".close").onclick = () => {dlg.remove();};
        document.body.appendChild(dlg);
        dlg.showModal();
    } else {
        let fileSaver = document.createElement("a");
        fileSaver.href = window.URL.createObjectURL(blob);
        fileSaver.download = Keymap.Name.replace(/[\*\?\\\/\:\"\<\>\|]/, "_") + ".keymap"
        fileSaver.click();
        fileSaver.remove();
    }
}

// IO layer: browser storage
var _PROFILE_ = {
    async read(prof) {
        if (prof)
            return localStorage.getItem(prof + ".keymap") || "";
        else {
            console.warn("Error! Empty profile name.");
            return "";
        }
    },
    async write(prof, data) {
        if (prof)
            localStorage.setItem(prof + ".keymap", data);
        else
            console.warn("Error! Empty profile name.");
    },
    async del(prof){
        if (prof)
            localStorage.removeItem(prof + ".keymap");
        else
            console.warn("Error! Empty profile name.");
    },
    async all() {
        let s = [];
        for (const k in localStorage) {
            if (k.endsWith(".keymap")) {
                s.push(k.slice(0, -7));
            }
        }
        return s;
    },
    async setLast(prof) {
        localStorage.setItem("_last", prof || "");
    },
    async getLast() {
        return localStorage.getItem("_last") || "";
    },
};

// If run by webwin, enable local-file profiles.
window.on_webwin_loaded = async () => {
    // IO layer: webwin fs
    window._PROFILE_ = {
        _data_fdr: "data",

        _datafile(filename) { return this._data_fdr + "\\" + filename; },
        _keymapfile(prof) { return this._datafile(prof + ".keymap"); },

        async read(prof) {
            try {
                return await webwin.fs.readfile(this._keymapfile(prof), "utf-8");
            } catch (e) {
                console.log(e);
                return "";
            }
        },
        async write(prof, data) {
            try {
                await webwin.fs.writefile(this._keymapfile(prof), data, "w", "utf-8");
            } catch (e) {
                console.log(e);
            }
        },
        async del(prof) {
            try {
                await webwin.fs.removefile(this._keymapfile(prof));
            } catch (e) {
                console.log(e);
            }
        },
        async all() {
            try {
                let s = [];
                (await webwin.fs.ls(this._data_fdr, "*.keymap", "file")).forEach(p => {
                    s.push(p.name.slice(0, -7));
                });
                return s;
            } catch (e) {
                console.log(e);
                return [];
            }
        },
        async setLast(prof) {
            try {
                await webwin.fs.writefile(this._datafile("_last"), prof || "", "w", "utf-8");
            } catch (e) {
                console.log(e);
            }
        },
        async getLast() {
            try {
                return await webwin.fs.readfile(this._datafile("_last"), "utf-8");
            } catch (e) {
                console.log(e);
                return "";
            }
        },
    }
    __loader__ = "„ÄêÁ≤æË£ÖÁ§ºÁõíÁâà *^____^* „Äë";
    UI.LaunchMode = "exe";
    await __init__();
};

var __appname__ = "ÈîÆË∞±";
var __version__ = "2.4.0-beta-2";
var __homepage__ = "https://github.com/cataerogong/keymap";
var __loader__ = "";

async function __init__() {
    Keymap._version = __version__;
    document.title = `${__appname__} ${__loader__}`.trim();
    document.querySelector(".about").innerHTML = `${__appname__} v${__version__} ${__loader__} Copyright &COPY; 2023-2024 CataeroGong [<a href="${__homepage__}">Project Home</a>]`;
    await UI.init();
}

__init__();

</script>
<!-- Img convert libraries -->
<script src="js/html2canvas.js"></script>
<script src="js/FileSaver.min.js"></script>
</body>
</html>